
C:\Users\borno\AppData\Local\Temp\arduino_build_832220/1.0.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
   0:	0f c0       	rjmp	.+30     	; 0x20 <__ctors_end>
   2:	33 c0       	rjmp	.+102    	; 0x6a <__bad_interrupt>
   4:	32 c0       	rjmp	.+100    	; 0x6a <__bad_interrupt>
   6:	31 c0       	rjmp	.+98     	; 0x6a <__bad_interrupt>
   8:	30 c0       	rjmp	.+96     	; 0x6a <__bad_interrupt>
   a:	2f c0       	rjmp	.+94     	; 0x6a <__bad_interrupt>
   c:	2e c0       	rjmp	.+92     	; 0x6a <__bad_interrupt>
   e:	2d c0       	rjmp	.+90     	; 0x6a <__bad_interrupt>
  10:	2c c0       	rjmp	.+88     	; 0x6a <__bad_interrupt>
  12:	2b c0       	rjmp	.+86     	; 0x6a <__bad_interrupt>
  14:	2a c0       	rjmp	.+84     	; 0x6a <__bad_interrupt>
  16:	29 c0       	rjmp	.+82     	; 0x6a <__bad_interrupt>
  18:	28 c0       	rjmp	.+80     	; 0x6a <__bad_interrupt>
  1a:	d6 c2       	rjmp	.+1452   	; 0x5c8 <__vector_13>
  1c:	5b c2       	rjmp	.+1206   	; 0x4d4 <__vector_14>

0000001e <__ctors_start>:
__trampolines_start():
  1e:	aa 03       	fmulsu	r18, r18

00000020 <__ctors_end>:
__dtors_end():
  20:	11 24       	eor	r1, r1
  22:	1f be       	out	0x3f, r1	; 63
  24:	cf e5       	ldi	r28, 0x5F	; 95
  26:	d2 e0       	ldi	r29, 0x02	; 2
  28:	de bf       	out	0x3e, r29	; 62
  2a:	cd bf       	out	0x3d, r28	; 61

0000002c <__do_clear_bss>:
__do_clear_bss():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
  2c:	20 e0       	ldi	r18, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
  2e:	a6 e6       	ldi	r26, 0x66	; 102
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
  30:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
  32:	01 c0       	rjmp	.+2      	; 0x36 <.do_clear_bss_start>

00000034 <.do_clear_bss_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
  34:	1d 92       	st	X+, r1

00000036 <.do_clear_bss_start>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
  36:	ad 3a       	cpi	r26, 0xAD	; 173
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
  38:	b2 07       	cpc	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
  3a:	e1 f7       	brne	.-8      	; 0x34 <.do_clear_bss_loop>

0000003c <__do_copy_data>:
__do_copy_data():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
  3c:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
  3e:	a0 e6       	ldi	r26, 0x60	; 96
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
  40:	b0 e0       	ldi	r27, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
  42:	e8 eb       	ldi	r30, 0xB8	; 184
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
  44:	f9 e0       	ldi	r31, 0x09	; 9
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
  46:	02 c0       	rjmp	.+4      	; 0x4c <__SREG__+0xd>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
  48:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
  4a:	0d 92       	st	X+, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
  4c:	a6 36       	cpi	r26, 0x66	; 102
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
  4e:	b1 07       	cpc	r27, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
  50:	d9 f7       	brne	.-10     	; 0x48 <__SREG__+0x9>

00000052 <__do_global_ctors>:
__do_global_ctors():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
  52:	10 e0       	ldi	r17, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
  54:	c0 e1       	ldi	r28, 0x10	; 16
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
  56:	d0 e0       	ldi	r29, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
  58:	03 c0       	rjmp	.+6      	; 0x60 <__do_global_ctors+0xe>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
  5a:	21 97       	sbiw	r28, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
  5c:	fe 01       	movw	r30, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
  5e:	7f d3       	rcall	.+1790   	; 0x75e <__tablejump2__>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
  60:	cf 30       	cpi	r28, 0x0F	; 15
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
  62:	d1 07       	cpc	r29, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
  64:	d1 f7       	brne	.-12     	; 0x5a <__do_global_ctors+0x8>
  66:	c9 d2       	rcall	.+1426   	; 0x5fa <main>
  68:	a5 c4       	rjmp	.+2378   	; 0x9b4 <_exit>

0000006a <__bad_interrupt>:
__vector_1():
  6a:	ca cf       	rjmp	.-108    	; 0x0 <__vectors>

0000006c <delay>:
delay():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:833
    // us is at least 4, divided by 4 gives us 1 (no zero delay bug)
    us >>= 2; // us div 4, = 4 cycles
  #endif

  // busy wait
  __asm__ __volatile__ (
  6c:	2c ec       	ldi	r18, 0xCC	; 204
  6e:	37 e0       	ldi	r19, 0x07	; 7
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:543
  }
  void yield(void) __attribute__ ((weak, alias("__empty")));

  void delay(unsigned long ms) //non-millis-timer-dependent delay()
  {
    while(ms--){
  70:	61 50       	subi	r22, 0x01	; 1
  72:	71 09       	sbc	r23, r1
  74:	81 09       	sbc	r24, r1
  76:	91 09       	sbc	r25, r1
  78:	08 f4       	brcc	.+2      	; 0x7c <delay+0x10>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:547
      yield();
      delayMicroseconds(1000);
    }
  }
  7a:	08 95       	ret
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:833
    // us is at least 4, divided by 4 gives us 1 (no zero delay bug)
    us >>= 2; // us div 4, = 4 cycles
  #endif

  // busy wait
  __asm__ __volatile__ (
  7c:	f9 01       	movw	r30, r18
  7e:	31 97       	sbiw	r30, 0x01	; 1
  80:	f1 f7       	brne	.-4      	; 0x7e <delay+0x12>
  82:	f6 cf       	rjmp	.-20     	; 0x70 <delay+0x4>

00000084 <USI_TWI_Master_Transfer>:
USI_TWI_Master_Transfer():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:225
 Data to be sent has to be placed into the USIDR prior to calling
 this function. Data read, will be return'ed from the function.
---------------------------------------------------------------*/
unsigned char USI_TWI_Master_Transfer(unsigned char temp)
{
  USISR = temp;                                          // Set USISR according to temp.
  84:	8e b9       	out	0x0e, r24	; 14
_delay_loop_1():
c:\users\borno\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:83
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
  86:	38 e2       	ldi	r19, 0x28	; 40
USI_TWI_Master_Transfer():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:233
         (1 << USIWM1) | (0 << USIWM0) |                 // Set USI in Two-wire mode.
         (1 << USICS1) | (0 << USICS0) | (1 << USICLK) | // Software clock strobe as source.
         (1 << USITC);                                   // Toggle Clock Port.
  do {
    if (USI_TWI_MASTER_SPEED) DELAY_T2TWI_FM; else DELAY_T2TWI;
    USICR = temp; // Generate positive SCL edge.
  88:	8b e2       	ldi	r24, 0x2B	; 43
_delay_loop_1():
c:\users\borno\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:83
  8a:	20 e2       	ldi	r18, 0x20	; 32
  8c:	93 2f       	mov	r25, r19
  8e:	9a 95       	dec	r25
  90:	f1 f7       	brne	.-4      	; 0x8e <USI_TWI_Master_Transfer+0xa>
USI_TWI_Master_Transfer():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:233
  92:	8d b9       	out	0x0d, r24	; 13
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:234
    while (!(PIN_USI_CL & (1 << PIN_USI_SCL)))
  94:	b2 9b       	sbis	0x16, 2	; 22
  96:	fe cf       	rjmp	.-4      	; 0x94 <USI_TWI_Master_Transfer+0x10>
_delay_loop_1():
c:\users\borno\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:83
  98:	92 2f       	mov	r25, r18
  9a:	9a 95       	dec	r25
  9c:	f1 f7       	brne	.-4      	; 0x9a <USI_TWI_Master_Transfer+0x16>
USI_TWI_Master_Transfer():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:237
      ; // Wait for SCL to go high.
    if (USI_TWI_MASTER_SPEED) DELAY_T4TWI_FM; else DELAY_T4TWI;
    USICR = temp;                   // Generate negative SCL edge.
  9e:	8d b9       	out	0x0d, r24	; 13
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:238
  } while (!(USISR & (1 << USIOIF))); // Check for transfer complete.
  a0:	76 9b       	sbis	0x0e, 6	; 14
  a2:	f4 cf       	rjmp	.-24     	; 0x8c <USI_TWI_Master_Transfer+0x8>
_delay_loop_1():
c:\users\borno\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:83
  a4:	88 e2       	ldi	r24, 0x28	; 40
  a6:	8a 95       	dec	r24
  a8:	f1 f7       	brne	.-4      	; 0xa6 <USI_TWI_Master_Transfer+0x22>
USI_TWI_Master_Transfer():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:241

  if (USI_TWI_MASTER_SPEED) DELAY_T2TWI_FM; else DELAY_T2TWI;
  temp  = USIDR;                 // Read out data.
  aa:	8f b1       	in	r24, 0x0f	; 15
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:242
  USIDR = 0xFF;                  // Release SDA.
  ac:	9f ef       	ldi	r25, 0xFF	; 255
  ae:	9f b9       	out	0x0f, r25	; 15
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:243
  DDR_USI |= (1 << PIN_USI_SDA); // Enable SDA as output.
  b0:	b8 9a       	sbi	0x17, 0	; 23
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:246

  return temp; // Return the data from the USIDR
}
  b2:	08 95       	ret

000000b4 <USI_TWI_Start_Transceiver_With_Data_Stop>:
USI_TWI_Start_Transceiver_With_Data_Stop():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:108
 parameter that defines if a Stop Condition should be send at the end
 of the transmission.
---------------------------------------------------------------*/

unsigned char USI_TWI_Start_Transceiver_With_Data_Stop(unsigned char *msg, unsigned char msgSize, unsigned char stop)
{
  b4:	ff 92       	push	r15
  b6:	0f 93       	push	r16
  b8:	1f 93       	push	r17
  ba:	cf 93       	push	r28
  bc:	df 93       	push	r29
  be:	16 2f       	mov	r17, r22
  c0:	04 2f       	mov	r16, r20
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:116

  unsigned char tempUSISR_1bit = (1 << USISIF) | (1 << USIOIF) | (1 << USIPF) | (1 << USIDC) | (0xE << USICNT0);
  // Prepare register value to: Clear flags, and set USI to shift 1 bit i.e. count 2 clock edges.

  USI_TWI_state.errorState  = 0;
  USI_TWI_state.addressMode = TRUE;
  c2:	21 e0       	ldi	r18, 0x01	; 1
  c4:	20 93 a5 00 	sts	0x00A5, r18	; 0x8000a5 <USI_TWI_state>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:146
    USI_TWI_state.errorState = USI_TWI_UE_DATA_COL;
    return (FALSE);
  }
#endif

  if (!(*msg & (1 << TWI_READ_BIT))) // The LSB in the address byte determines if is a masterRead or masterWrite operation.
  c8:	fc 01       	movw	r30, r24
  ca:	20 81       	ld	r18, Z
  cc:	20 fd       	sbrc	r18, 0
  ce:	03 c0       	rjmp	.+6      	; 0xd6 <USI_TWI_Start_Transceiver_With_Data_Stop+0x22>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:148
  {
    USI_TWI_state.masterWriteDataMode = TRUE;
  d0:	23 e0       	ldi	r18, 0x03	; 3
  d2:	20 93 a5 00 	sts	0x00A5, r18	; 0x8000a5 <USI_TWI_state>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:152
  }

  /* Release SCL to ensure that (repeated) Start can be performed */
  PORT_USI_CL |= (1 << PIN_USI_SCL); // Release SCL.
  d6:	c2 9a       	sbi	0x18, 2	; 24
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:153
  while (!(PIN_USI_CL & (1 << PIN_USI_SCL)))
  d8:	b2 9b       	sbis	0x16, 2	; 22
  da:	fe cf       	rjmp	.-4      	; 0xd8 <USI_TWI_Start_Transceiver_With_Data_Stop+0x24>
_delay_loop_1():
c:\users\borno\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:83
  dc:	28 e2       	ldi	r18, 0x28	; 40
  de:	2a 95       	dec	r18
  e0:	f1 f7       	brne	.-4      	; 0xde <USI_TWI_Start_Transceiver_With_Data_Stop+0x2a>
USI_TWI_Start_Transceiver_With_Data_Stop():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:159
    ; // Verify that SCL becomes high.
  if (USI_TWI_MASTER_SPEED) DELAY_T4TWI_FM; // Delay for T4TWI if TWI_FAST_MODE
  else DELAY_T2TWI;    // Delay for T2TWI if TWI_STANDARD_MODE

  /* Generate Start Condition */
  PORT_USI &= ~(1 << PIN_USI_SDA); // Force SDA LOW.
  e2:	c0 98       	cbi	0x18, 0	; 24
_delay_loop_1():
c:\users\borno\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:83
  e4:	20 e2       	ldi	r18, 0x20	; 32
  e6:	2a 95       	dec	r18
  e8:	f1 f7       	brne	.-4      	; 0xe6 <USI_TWI_Start_Transceiver_With_Data_Stop+0x32>
USI_TWI_Start_Transceiver_With_Data_Stop():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:163

  if (USI_TWI_MASTER_SPEED) DELAY_T4TWI_FM; else DELAY_T4TWI; // UGGGGLLLYYYYY - but if you never call clock() which is the only thing that could change USI_TWI_MASTER_SPEED, should be optimized out

  PORT_USI_CL &= ~(1 << PIN_USI_SCL); // Pull SCL LOW.
  ea:	c2 98       	cbi	0x18, 2	; 24
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:164
  PORT_USI |= (1 << PIN_USI_SDA);  // Release SDA.
  ec:	c0 9a       	sbi	0x18, 0	; 24
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:167

#ifdef SIGNAL_VERIFY
  if (!(USISR & (1 << USISIF))) {
  ee:	77 99       	sbic	0x0e, 7	; 14
  f0:	0a c0       	rjmp	.+20     	; 0x106 <USI_TWI_Start_Transceiver_With_Data_Stop+0x52>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:168
    USI_TWI_state.errorState = USI_TWI_MISSING_START_CON;
  f2:	87 e0       	ldi	r24, 0x07	; 7
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:186

      /* Clock and verify (N)ACK from slave */
      DDR_USI &= ~(1 << PIN_USI_SDA); // Enable SDA as input.
      if (USI_TWI_Master_Transfer(tempUSISR_1bit) & (1 << TWI_NACK_BIT)) {
        if (USI_TWI_state.addressMode)
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_ADDRESS;
  f4:	80 93 a5 00 	sts	0x00A5, r24	; 0x8000a5 <USI_TWI_state>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:189
        else
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_DATA;
        return (FALSE);
  f8:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:216
    USI_TWI_Master_Stop(); // Send a STOP condition on the TWI bus.
  }

  /* Transmission successfully completed*/
  return (TRUE);
}
  fa:	df 91       	pop	r29
  fc:	cf 91       	pop	r28
  fe:	1f 91       	pop	r17
 100:	0f 91       	pop	r16
 102:	ff 90       	pop	r15
 104:	08 95       	ret
 106:	ec 01       	movw	r28, r24
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:202
      *(msg++) = USI_TWI_Master_Transfer(tempUSISR_8bit);

      /* Prepare to generate ACK (or NACK in case of End Of Transmission) */
      if (msgSize == 1) // If transmission of last byte was performed.
      {
        USIDR = 0xFF; // Load NACK to confirm End Of Transmission.
 108:	ff 24       	eor	r15, r15
 10a:	fa 94       	dec	r15
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:176
#endif

  /*Write address and Read/Write data */
  do {
    /* If masterWrite cycle (or initial address transmission)*/
    if (USI_TWI_state.addressMode || USI_TWI_state.masterWriteDataMode) {
 10c:	80 91 a5 00 	lds	r24, 0x00A5	; 0x8000a5 <USI_TWI_state>
 110:	83 70       	andi	r24, 0x03	; 3
 112:	19 f1       	breq	.+70     	; 0x15a <USI_TWI_Start_Transceiver_With_Data_Stop+0xa6>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:178
      /* Write a byte */
      PORT_USI_CL &= ~(1 << PIN_USI_SCL);         // Pull SCL LOW.
 114:	c2 98       	cbi	0x18, 2	; 24
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:179
      USIDR = *(msg++);                        // Setup data.
 116:	88 81       	ld	r24, Y
 118:	8f b9       	out	0x0f, r24	; 15
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:180
      USI_TWI_Master_Transfer(tempUSISR_8bit); // Send 8 bits on bus.
 11a:	80 ef       	ldi	r24, 0xF0	; 240
 11c:	b3 df       	rcall	.-154    	; 0x84 <USI_TWI_Master_Transfer>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:183

      /* Clock and verify (N)ACK from slave */
      DDR_USI &= ~(1 << PIN_USI_SDA); // Enable SDA as input.
 11e:	b8 98       	cbi	0x17, 0	; 23
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:184
      if (USI_TWI_Master_Transfer(tempUSISR_1bit) & (1 << TWI_NACK_BIT)) {
 120:	8e ef       	ldi	r24, 0xFE	; 254
 122:	b0 df       	rcall	.-160    	; 0x84 <USI_TWI_Master_Transfer>
 124:	80 ff       	sbrs	r24, 0
 126:	0c c0       	rjmp	.+24     	; 0x140 <USI_TWI_Start_Transceiver_With_Data_Stop+0x8c>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:185
        if (USI_TWI_state.addressMode)
 128:	90 91 a5 00 	lds	r25, 0x00A5	; 0x8000a5 <USI_TWI_state>
 12c:	89 2f       	mov	r24, r25
 12e:	81 70       	andi	r24, 0x01	; 1
 130:	90 ff       	sbrs	r25, 0
 132:	02 c0       	rjmp	.+4      	; 0x138 <USI_TWI_Start_Transceiver_With_Data_Stop+0x84>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:186
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_ADDRESS;
 134:	86 e0       	ldi	r24, 0x06	; 6
 136:	de cf       	rjmp	.-68     	; 0xf4 <USI_TWI_Start_Transceiver_With_Data_Stop+0x40>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:188
        else
          USI_TWI_state.errorState = USI_TWI_NO_ACK_ON_DATA;
 138:	95 e0       	ldi	r25, 0x05	; 5
 13a:	90 93 a5 00 	sts	0x00A5, r25	; 0x8000a5 <USI_TWI_state>
 13e:	dd cf       	rjmp	.-70     	; 0xfa <USI_TWI_Start_Transceiver_With_Data_Stop+0x46>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:191
        return (FALSE);
      }
      USI_TWI_state.addressMode = FALSE; // Only perform address transmission once.
 140:	80 91 a5 00 	lds	r24, 0x00A5	; 0x8000a5 <USI_TWI_state>
 144:	8e 7f       	andi	r24, 0xFE	; 254
 146:	80 93 a5 00 	sts	0x00A5, r24	; 0x8000a5 <USI_TWI_state>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:208
      } else {
        USIDR = 0x00; // Load ACK. Set data register bit 7 (output for SDA) low.
      }
      USI_TWI_Master_Transfer(tempUSISR_1bit); // Generate ACK/NACK.
    }
  } while (--msgSize); // Until all data sent/received.
 14a:	11 50       	subi	r17, 0x01	; 1
 14c:	21 96       	adiw	r28, 0x01	; 1
 14e:	11 11       	cpse	r17, r1
 150:	dd cf       	rjmp	.-70     	; 0x10c <USI_TWI_Start_Transceiver_With_Data_Stop+0x58>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:210

  if (stop) {
 152:	01 11       	cpse	r16, r1
 154:	0e c0       	rjmp	.+28     	; 0x172 <USI_TWI_Start_Transceiver_With_Data_Stop+0xbe>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:215
    USI_TWI_Master_Stop(); // Send a STOP condition on the TWI bus.
  }

  /* Transmission successfully completed*/
  return (TRUE);
 156:	81 e0       	ldi	r24, 0x01	; 1
 158:	d0 cf       	rjmp	.-96     	; 0xfa <USI_TWI_Start_Transceiver_With_Data_Stop+0x46>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:196
      USI_TWI_state.addressMode = FALSE; // Only perform address transmission once.
    }
    /* Else masterRead cycle*/
    else {
      /* Read a data byte */
      DDR_USI &= ~(1 << PIN_USI_SDA); // Enable SDA as input.
 15a:	b8 98       	cbi	0x17, 0	; 23
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:197
      *(msg++) = USI_TWI_Master_Transfer(tempUSISR_8bit);
 15c:	80 ef       	ldi	r24, 0xF0	; 240
 15e:	92 df       	rcall	.-220    	; 0x84 <USI_TWI_Master_Transfer>
 160:	88 83       	st	Y, r24
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:200

      /* Prepare to generate ACK (or NACK in case of End Of Transmission) */
      if (msgSize == 1) // If transmission of last byte was performed.
 162:	11 30       	cpi	r17, 0x01	; 1
 164:	21 f4       	brne	.+8      	; 0x16e <USI_TWI_Start_Transceiver_With_Data_Stop+0xba>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:202
      {
        USIDR = 0xFF; // Load NACK to confirm End Of Transmission.
 166:	ff b8       	out	0x0f, r15	; 15
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:206
      } else {
        USIDR = 0x00; // Load ACK. Set data register bit 7 (output for SDA) low.
      }
      USI_TWI_Master_Transfer(tempUSISR_1bit); // Generate ACK/NACK.
 168:	8e ef       	ldi	r24, 0xFE	; 254
 16a:	8c df       	rcall	.-232    	; 0x84 <USI_TWI_Master_Transfer>
 16c:	ee cf       	rjmp	.-36     	; 0x14a <USI_TWI_Start_Transceiver_With_Data_Stop+0x96>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:204
      /* Prepare to generate ACK (or NACK in case of End Of Transmission) */
      if (msgSize == 1) // If transmission of last byte was performed.
      {
        USIDR = 0xFF; // Load NACK to confirm End Of Transmission.
      } else {
        USIDR = 0x00; // Load ACK. Set data register bit 7 (output for SDA) low.
 16e:	1f b8       	out	0x0f, r1	; 15
 170:	fb cf       	rjmp	.-10     	; 0x168 <USI_TWI_Start_Transceiver_With_Data_Stop+0xb4>
USI_TWI_Master_Stop():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:254
 Function for generating a TWI Stop Condition. Used to release
 the TWI bus.
---------------------------------------------------------------*/
unsigned char USI_TWI_Master_Stop(void)
{
  PORT_USI &= ~(1 << PIN_USI_SDA); // Pull SDA low.
 172:	c0 98       	cbi	0x18, 0	; 24
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:255
  PORT_USI_CL |= (1 << PIN_USI_SCL);  // Release SCL.
 174:	c2 9a       	sbi	0x18, 2	; 24
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:256
  while (!(PIN_USI_CL & (1 << PIN_USI_SCL)))
 176:	b2 9b       	sbis	0x16, 2	; 22
 178:	fe cf       	rjmp	.-4      	; 0x176 <USI_TWI_Start_Transceiver_With_Data_Stop+0xc2>
_delay_loop_1():
c:\users\borno\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:83
 17a:	80 e2       	ldi	r24, 0x20	; 32
 17c:	8a 95       	dec	r24
 17e:	f1 f7       	brne	.-4      	; 0x17c <USI_TWI_Start_Transceiver_With_Data_Stop+0xc8>
USI_TWI_Master_Stop():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:259
    ; // Wait for SCL to go high.
  if (USI_TWI_MASTER_SPEED) DELAY_T4TWI_FM; else DELAY_T4TWI;
  PORT_USI |= (1 << PIN_USI_SDA); // Release SDA.
 180:	c0 9a       	sbi	0x18, 0	; 24
_delay_loop_1():
c:\users\borno\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/delay_basic.h:83
 182:	88 e2       	ldi	r24, 0x28	; 40
 184:	8a 95       	dec	r24
 186:	f1 f7       	brne	.-4      	; 0x184 <USI_TWI_Start_Transceiver_With_Data_Stop+0xd0>
USI_TWI_Master_Stop():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:263
  if (USI_TWI_MASTER_SPEED) DELAY_T2TWI_FM; else DELAY_T2TWI;

#ifdef SIGNAL_VERIFY
  if (!(USISR & (1 << USIPF))) {
 188:	75 99       	sbic	0x0e, 5	; 14
 18a:	e5 cf       	rjmp	.-54     	; 0x156 <USI_TWI_Start_Transceiver_With_Data_Stop+0xa2>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:264
    USI_TWI_state.errorState = USI_TWI_MISSING_STOP_CON;
 18c:	88 e0       	ldi	r24, 0x08	; 8
 18e:	80 93 a5 00 	sts	0x00A5, r24	; 0x8000a5 <USI_TWI_state>
 192:	e1 cf       	rjmp	.-62     	; 0x156 <USI_TWI_Start_Transceiver_With_Data_Stop+0xa2>

00000194 <TwoWire::endTransmission(unsigned char) [clone .constprop.24]>:
_ZN7TwoWire15endTransmissionEh.constprop.24():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:478

uint8_t TwoWire::endTransmission(uint8_t sendStop) {
  // transmit buffer (blocking)
  uint8_t ret = USI_TWI_Start_Transceiver_With_Data_Stop(Buffer,
                                                         BufferLength,
                                                         sendStop);
 194:	48 2f       	mov	r20, r24
 196:	60 91 a8 00 	lds	r22, 0x00A8	; 0x8000a8 <TwoWire::BufferLength>
 19a:	86 e6       	ldi	r24, 0x66	; 102
 19c:	90 e0       	ldi	r25, 0x00	; 0
 19e:	8a df       	rcall	.-236    	; 0xb4 <USI_TWI_Start_Transceiver_With_Data_Stop>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:480
  // reset tx buffer iterator vars
  BufferIndex = 0;
 1a0:	10 92 a7 00 	sts	0x00A7, r1	; 0x8000a7 <TwoWire::BufferIndex>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:481
  BufferLength = 0;
 1a4:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <TwoWire::BufferLength>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:483
  // indicate that we are done transmitting
  transmitting = 0;
 1a8:	10 92 a6 00 	sts	0x00A6, r1	; 0x8000a6 <TwoWire::transmitting>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:485
  // check for error
  if (ret == FALSE) {
 1ac:	81 11       	cpse	r24, r1
 1ae:	10 c0       	rjmp	.+32     	; 0x1d0 <TwoWire::endTransmission(unsigned char) [clone .constprop.24]+0x3c>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:486
    switch (USI_TWI_Get_State_Info()) {
 1b0:	80 91 a5 00 	lds	r24, 0x00A5	; 0x8000a5 <USI_TWI_state>
 1b4:	85 30       	cpi	r24, 0x05	; 5
 1b6:	41 f0       	breq	.+16     	; 0x1c8 <TwoWire::endTransmission(unsigned char) [clone .constprop.24]+0x34>
 1b8:	86 30       	cpi	r24, 0x06	; 6
 1ba:	21 f0       	breq	.+8      	; 0x1c4 <TwoWire::endTransmission(unsigned char) [clone .constprop.24]+0x30>
 1bc:	81 30       	cpi	r24, 0x01	; 1
 1be:	31 f4       	brne	.+12     	; 0x1cc <TwoWire::endTransmission(unsigned char) [clone .constprop.24]+0x38>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:488
    case USI_TWI_DATA_OUT_OF_BOUND:
      return 1; //data too long to fit in transmit buffer
 1c0:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:497
      return 3; //received NACK on transmit of data
    }
    return 4; //other error
  }
  return 0; //success
}
 1c2:	08 95       	ret
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:490
  if (ret == FALSE) {
    switch (USI_TWI_Get_State_Info()) {
    case USI_TWI_DATA_OUT_OF_BOUND:
      return 1; //data too long to fit in transmit buffer
    case USI_TWI_NO_ACK_ON_ADDRESS:
      return 2; //received NACK on transmit of address
 1c4:	82 e0       	ldi	r24, 0x02	; 2
 1c6:	08 95       	ret
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:492
    case USI_TWI_NO_ACK_ON_DATA:
      return 3; //received NACK on transmit of data
 1c8:	83 e0       	ldi	r24, 0x03	; 3
 1ca:	08 95       	ret
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:494
    }
    return 4; //other error
 1cc:	84 e0       	ldi	r24, 0x04	; 4
 1ce:	08 95       	ret
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:496
  }
  return 0; //success
 1d0:	80 e0       	ldi	r24, 0x00	; 0
 1d2:	08 95       	ret

000001d4 <USI_TWI_Master_Initialise>:
USI_TWI_Master_Initialise():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:61
{
  #ifdef PUE_USI
  PUE_USI |=(1 << PIN_USI_SDA);
  PUE_USI_CL |=(1 << PIN_USI_SCL);
  #endif
  PORT_USI |= (1 << PIN_USI_SDA); // Enable pullup on SDA, to set high as released state.
 1d4:	c0 9a       	sbi	0x18, 0	; 24
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:62
  PORT_USI_CL |= (1 << PIN_USI_SCL); // Enable pullup on SCL, to set high as released state.
 1d6:	c2 9a       	sbi	0x18, 2	; 24
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:64

  DDR_USI_CL |= (1 << PIN_USI_SCL); // Enable SCL as output.
 1d8:	ba 9a       	sbi	0x17, 2	; 23
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:65
  DDR_USI |= (1 << PIN_USI_SDA); // Enable SDA as output.
 1da:	b8 9a       	sbi	0x17, 0	; 23
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:67

  USIDR = 0xFF;                                           // Preload dataregister with "released level" data.
 1dc:	8f ef       	ldi	r24, 0xFF	; 255
 1de:	8f b9       	out	0x0f, r24	; 15
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:68
  USICR = (0 << USISIE) | (0 << USIOIE) |                 // Disable Interrupts.
 1e0:	8a e2       	ldi	r24, 0x2A	; 42
 1e2:	8d b9       	out	0x0d, r24	; 13
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:72
          (1 << USIWM1) | (0 << USIWM0) |                 // Set USI in Two-wire mode.
          (1 << USICS1) | (0 << USICS0) | (1 << USICLK) | // Software stobe as counter clock source
          (0 << USITC);
  USISR = (1 << USISIF) | (1 << USIOIF) | (1 << USIPF) | (1 << USIDC) | // Clear flags,
 1e4:	80 ef       	ldi	r24, 0xF0	; 240
 1e6:	8e b9       	out	0x0e, r24	; 14
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Master/USI_TWI_Master.c:74
          (0x0 << USICNT0);                                             // and reset counter.
}
 1e8:	08 95       	ret

000001ea <TwoWire::write(unsigned char const*, unsigned int)>:
_ZN7TwoWire5writeEPKhj():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:531
}

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity) {
 1ea:	cf 93       	push	r28
 1ec:	df 93       	push	r29
write():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:507

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data) {
  if (transmitting) { // in master transmitter mode
 1ee:	d0 91 a6 00 	lds	r29, 0x00A6	; 0x8000a6 <TwoWire::transmitting>
 1f2:	80 91 a8 00 	lds	r24, 0x00A8	; 0x8000a8 <TwoWire::BufferLength>
 1f6:	20 91 a7 00 	lds	r18, 0x00A7	; 0x8000a7 <TwoWire::BufferIndex>
_ZN7TwoWire5writeEPKhj():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:533
// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity) {
  size_t numBytes = 0;
  for (size_t i = 0; i < quantity; ++i){
 1fa:	f0 e0       	ldi	r31, 0x00	; 0
 1fc:	e0 e0       	ldi	r30, 0x00	; 0
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:532

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity) {
  size_t numBytes = 0;
 1fe:	b0 e0       	ldi	r27, 0x00	; 0
 200:	a0 e0       	ldi	r26, 0x00	; 0
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:533
  for (size_t i = 0; i < quantity; ++i){
 202:	e4 17       	cp	r30, r20
 204:	f5 07       	cpc	r31, r21
 206:	78 f5       	brcc	.+94     	; 0x266 <__stack+0x7>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:534
    numBytes += write(data[i]);
 208:	fb 01       	movw	r30, r22
 20a:	c0 81       	ld	r28, Z
write():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:507

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data) {
  if (transmitting) { // in master transmitter mode
 20c:	dd 23       	and	r29, r29
 20e:	81 f0       	breq	.+32     	; 0x230 <TwoWire::write(unsigned char const*, unsigned int)+0x46>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:509
    // don't bother if buffer is full
    if (BufferLength >= TWI_BUFFER_SIZE) {
 210:	80 32       	cpi	r24, 0x20	; 32
 212:	30 f5       	brcc	.+76     	; 0x260 <__stack+0x1>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:513
      return 0;
    }
    // put byte in tx buffer
    Buffer[BufferIndex] = data;
 214:	e2 2f       	mov	r30, r18
 216:	f0 e0       	ldi	r31, 0x00	; 0
 218:	ea 59       	subi	r30, 0x9A	; 154
 21a:	ff 4f       	sbci	r31, 0xFF	; 255
 21c:	c0 83       	st	Z, r28
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:514
    ++BufferIndex;
 21e:	2f 5f       	subi	r18, 0xFF	; 255
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:516
    // update amount in buffer
    BufferLength = BufferIndex;
 220:	82 2f       	mov	r24, r18
_ZN7TwoWire5writeEPKhj():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:525
      return 0;
    }
    // reply to master
    USI_TWI_Transmit_Byte(data);
  }
  return 1;
 222:	e1 e0       	ldi	r30, 0x01	; 1
 224:	f0 e0       	ldi	r31, 0x00	; 0
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:534
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity) {
  size_t numBytes = 0;
  for (size_t i = 0; i < quantity; ++i){
    numBytes += write(data[i]);
 226:	ae 0f       	add	r26, r30
 228:	bf 1f       	adc	r27, r31
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:533
// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity) {
  size_t numBytes = 0;
  for (size_t i = 0; i < quantity; ++i){
 22a:	e1 e0       	ldi	r30, 0x01	; 1
 22c:	f0 e0       	ldi	r31, 0x00	; 0
 22e:	e9 cf       	rjmp	.-46     	; 0x202 <TwoWire::write(unsigned char const*, unsigned int)+0x18>
USI_TWI_Space_In_Transmission_Buffer():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:144

// Check if there is space in the transmission buffer.
unsigned char USI_TWI_Space_In_Transmission_Buffer(void)
{
  unsigned char tmpTxHead;
  tmpTxHead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate next buffer index.
 230:	30 91 87 00 	lds	r19, 0x0087	; 0x800087 <TWI_TxHead>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:145
  return (TWI_TxTail - tmpTxHead) & TWI_TX_BUFFER_MASK; // Return 0 (FALSE) if the transmission buffer is full.
 234:	90 91 86 00 	lds	r25, 0x0086	; 0x800086 <TWI_TxTail>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:144

// Check if there is space in the transmission buffer.
unsigned char USI_TWI_Space_In_Transmission_Buffer(void)
{
  unsigned char tmpTxHead;
  tmpTxHead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate next buffer index.
 238:	3f 5f       	subi	r19, 0xFF	; 255
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:145
  return (TWI_TxTail - tmpTxHead) & TWI_TX_BUFFER_MASK; // Return 0 (FALSE) if the transmission buffer is full.
 23a:	93 1b       	sub	r25, r19
 23c:	9f 70       	andi	r25, 0x0F	; 15
write():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:519
    ++BufferIndex;
    // update amount in buffer
    BufferLength = BufferIndex;
  } else { // in slave send mode
    // don't bother if buffer is full
    if (!USI_TWI_Space_In_Transmission_Buffer()) {
 23e:	81 f0       	breq	.+32     	; 0x260 <__stack+0x1>
USI_TWI_Transmit_Byte():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:100
// Puts data in the transmission buffer, Waits if buffer is full.
void USI_TWI_Transmit_Byte(unsigned char data)
{
  unsigned char tmphead;

  tmphead = (TWI_TxHead + 1) & TWI_TX_BUFFER_MASK; // Calculate buffer index.
 240:	90 91 87 00 	lds	r25, 0x0087	; 0x800087 <TWI_TxHead>
 244:	9f 5f       	subi	r25, 0xFF	; 255
 246:	9f 70       	andi	r25, 0x0F	; 15
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:101
  while (tmphead == TWI_TxTail)
 248:	30 91 86 00 	lds	r19, 0x0086	; 0x800086 <TWI_TxTail>
 24c:	93 17       	cp	r25, r19
 24e:	e1 f3       	breq	.-8      	; 0x248 <TwoWire::write(unsigned char const*, unsigned int)+0x5e>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:103
    ;                         // Wait for free space in buffer.
  TWI_TxBuf[tmphead] = data;    // Store data in buffer.
 250:	e9 2f       	mov	r30, r25
 252:	f0 e0       	ldi	r31, 0x00	; 0
 254:	ea 58       	subi	r30, 0x8A	; 138
 256:	ff 4f       	sbci	r31, 0xFF	; 255
 258:	c0 83       	st	Z, r28
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:104
  TWI_TxHead         = tmphead; // Store new index.
 25a:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <TWI_TxHead>
 25e:	e1 cf       	rjmp	.-62     	; 0x222 <TwoWire::write(unsigned char const*, unsigned int)+0x38>
_ZN7TwoWire5writeEPKhj():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:520
      return 0;
 260:	f0 e0       	ldi	r31, 0x00	; 0
 262:	e0 e0       	ldi	r30, 0x00	; 0
 264:	e0 cf       	rjmp	.-64     	; 0x226 <TwoWire::write(unsigned char const*, unsigned int)+0x3c>
 266:	20 93 a7 00 	sts	0x00A7, r18	; 0x8000a7 <TwoWire::BufferIndex>
 26a:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <TwoWire::BufferLength>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:537
  size_t numBytes = 0;
  for (size_t i = 0; i < quantity; ++i){
    numBytes += write(data[i]);
  }
  return numBytes;
}
 26e:	cd 01       	movw	r24, r26
 270:	df 91       	pop	r29
 272:	cf 91       	pop	r28
 274:	08 95       	ret

00000276 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.18]>:
_ZN18Adafruit_I2CDevice5writeEPKhjbS1_j.constprop.18():
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:93
 *            ensure the content of this buffer doesn't change.
 *    @param  prefix_len Number of bytes from prefix buffer to write
 *    @param  stop Whether to send an I2C STOP signal on write
 *    @return True if write was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write(const uint8_t *buffer, size_t len, bool stop,
 276:	0f 93       	push	r16
 278:	1f 93       	push	r17
 27a:	cf 93       	push	r28
 27c:	df 93       	push	r29
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:96
                               const uint8_t *prefix_buffer,
                               size_t prefix_len) {
  if ((len + prefix_len) > maxBufferSize()) {
 27e:	e1 e0       	ldi	r30, 0x01	; 1
 280:	f0 e0       	ldi	r31, 0x00	; 0
 282:	21 15       	cp	r18, r1
 284:	31 05       	cpc	r19, r1
 286:	11 f0       	breq	.+4      	; 0x28c <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.18]+0x16>
 288:	e2 e0       	ldi	r30, 0x02	; 2
 28a:	f0 e0       	ldi	r31, 0x00	; 0
 28c:	ec 01       	movw	r28, r24
 28e:	ac 81       	ldd	r26, Y+4	; 0x04
 290:	bd 81       	ldd	r27, Y+5	; 0x05
 292:	ae 17       	cp	r26, r30
 294:	bf 07       	cpc	r27, r31
 296:	10 f4       	brcc	.+4      	; 0x29c <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.18]+0x26>
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:152
  if (stop) {
    DEBUG_SERIAL.print("\tSTOP");
  }
#endif

  if (_wire->endTransmission(stop) == 0) {
 298:	90 e0       	ldi	r25, 0x00	; 0
 29a:	1e c0       	rjmp	.+60     	; 0x2d8 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.18]+0x62>
 29c:	fa 01       	movw	r30, r20
 29e:	8b 01       	movw	r16, r22
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:106
    DEBUG_SERIAL.println(F("\tI2CDevice could not write such a large buffer"));
#endif
    return false;
  }

  _wire->beginTransmission(_addr);
 2a0:	a9 81       	ldd	r26, Y+1	; 0x01
 2a2:	ba 81       	ldd	r27, Y+2	; 0x02
 2a4:	48 81       	ld	r20, Y
beginTransmission():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:462
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)sendStop);
}

void TwoWire::beginTransmission(uint8_t address) {
  // indicate that we are transmitting
  transmitting = 1;
 2a6:	91 e0       	ldi	r25, 0x01	; 1
 2a8:	90 93 a6 00 	sts	0x00A6, r25	; 0x8000a6 <TwoWire::transmitting>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:464
  // set address of targeted slave and write mode
  Buffer[0] = (address << TWI_ADR_BITS) | (0 << TWI_READ_BIT);
 2ac:	44 0f       	add	r20, r20
 2ae:	40 93 66 00 	sts	0x0066, r20	; 0x800066 <__data_end>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:466
  // reset tx buffer iterator vars
  BufferIndex = 1; // reserved by slave address
 2b2:	90 93 a7 00 	sts	0x00A7, r25	; 0x8000a7 <TwoWire::BufferIndex>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:467
  BufferLength = BufferIndex;
 2b6:	90 93 a8 00 	sts	0x00A8, r25	; 0x8000a8 <TwoWire::BufferLength>
_ZN18Adafruit_I2CDevice5writeEPKhjbS1_j.constprop.18():
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:109

  // Write the prefix data (usually an address)
  if ((prefix_len != 0) && (prefix_buffer != NULL)) {
 2ba:	23 2b       	or	r18, r19
 2bc:	99 f4       	brne	.+38     	; 0x2e4 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.18]+0x6e>
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:119
      return false;
    }
  }

  // Write the data itself
  if (_wire->write(buffer, len) != len) {
 2be:	41 e0       	ldi	r20, 0x01	; 1
 2c0:	50 e0       	ldi	r21, 0x00	; 0
 2c2:	b8 01       	movw	r22, r16
 2c4:	89 81       	ldd	r24, Y+1	; 0x01
 2c6:	9a 81       	ldd	r25, Y+2	; 0x02
 2c8:	90 df       	rcall	.-224    	; 0x1ea <TwoWire::write(unsigned char const*, unsigned int)>
 2ca:	01 97       	sbiw	r24, 0x01	; 1
 2cc:	29 f7       	brne	.-54     	; 0x298 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.18]+0x22>
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:152
  if (stop) {
    DEBUG_SERIAL.print("\tSTOP");
  }
#endif

  if (_wire->endTransmission(stop) == 0) {
 2ce:	81 e0       	ldi	r24, 0x01	; 1
 2d0:	61 df       	rcall	.-318    	; 0x194 <TwoWire::endTransmission(unsigned char) [clone .constprop.24]>
 2d2:	91 e0       	ldi	r25, 0x01	; 1
 2d4:	81 11       	cpse	r24, r1
 2d6:	e0 cf       	rjmp	.-64     	; 0x298 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.18]+0x22>
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:164
#ifdef DEBUG_SERIAL
    DEBUG_SERIAL.println("\tFailed to send!");
#endif
    return false;
  }
}
 2d8:	89 2f       	mov	r24, r25
 2da:	df 91       	pop	r29
 2dc:	cf 91       	pop	r28
 2de:	1f 91       	pop	r17
 2e0:	0f 91       	pop	r16
 2e2:	08 95       	ret
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:109
  }

  _wire->beginTransmission(_addr);

  // Write the prefix data (usually an address)
  if ((prefix_len != 0) && (prefix_buffer != NULL)) {
 2e4:	30 97       	sbiw	r30, 0x00	; 0
 2e6:	59 f3       	breq	.-42     	; 0x2be <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.18]+0x48>
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:110
    if (_wire->write(prefix_buffer, prefix_len) != prefix_len) {
 2e8:	41 e0       	ldi	r20, 0x01	; 1
 2ea:	50 e0       	ldi	r21, 0x00	; 0
 2ec:	bf 01       	movw	r22, r30
 2ee:	cd 01       	movw	r24, r26
 2f0:	7c df       	rcall	.-264    	; 0x1ea <TwoWire::write(unsigned char const*, unsigned int)>
 2f2:	01 97       	sbiw	r24, 0x01	; 1
 2f4:	89 f6       	brne	.-94     	; 0x298 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.18]+0x22>
 2f6:	e3 cf       	rjmp	.-58     	; 0x2be <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.18]+0x48>

000002f8 <Adafruit_I2CDevice::detected()>:
_ZN18Adafruit_I2CDevice8detectedEv():
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:60
/*!
 *    @brief  Scans I2C for the address - note will give a false-positive
 *    if there's no pullups on I2C
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::detected(void) {
 2f8:	cf 93       	push	r28
 2fa:	df 93       	push	r29
 2fc:	ec 01       	movw	r28, r24
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:62
  // Init I2C if not done yet
  if (!_begun && !begin()) {
 2fe:	8b 81       	ldd	r24, Y+3	; 0x03
 300:	88 23       	and	r24, r24
 302:	99 f0       	breq	.+38     	; 0x32a <Adafruit_I2CDevice::detected()+0x32>
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:67
    return false;
  }

  // A basic scanner, see if it ACK's
  _wire->beginTransmission(_addr);
 304:	98 81       	ld	r25, Y
beginTransmission():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:462
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)sendStop);
}

void TwoWire::beginTransmission(uint8_t address) {
  // indicate that we are transmitting
  transmitting = 1;
 306:	81 e0       	ldi	r24, 0x01	; 1
 308:	80 93 a6 00 	sts	0x00A6, r24	; 0x8000a6 <TwoWire::transmitting>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:464
  // set address of targeted slave and write mode
  Buffer[0] = (address << TWI_ADR_BITS) | (0 << TWI_READ_BIT);
 30c:	99 0f       	add	r25, r25
 30e:	90 93 66 00 	sts	0x0066, r25	; 0x800066 <__data_end>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:466
  // reset tx buffer iterator vars
  BufferIndex = 1; // reserved by slave address
 312:	80 93 a7 00 	sts	0x00A7, r24	; 0x8000a7 <TwoWire::BufferIndex>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:467
  BufferLength = BufferIndex;
 316:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <TwoWire::BufferLength>
endTransmission():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:500
  }
  return 0; //success
}

uint8_t TwoWire::endTransmission(void) {
  return endTransmission(true);
 31a:	3c df       	rcall	.-392    	; 0x194 <TwoWire::endTransmission(unsigned char) [clone .constprop.24]>
_ZN18Adafruit_I2CDevice8detectedEv():
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:68
  if (_wire->endTransmission() == 0) {
 31c:	91 e0       	ldi	r25, 0x01	; 1
 31e:	81 11       	cpse	r24, r1
 320:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:78
  }
#ifdef DEBUG_SERIAL
  DEBUG_SERIAL.println(F("Not detected"));
#endif
  return false;
}
 322:	89 2f       	mov	r24, r25
 324:	df 91       	pop	r29
 326:	cf 91       	pop	r28
 328:	08 95       	ret
begin():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:364
}

// Public Methods //////////////////////////////////////////////////////////////

void TwoWire::begin(void) {
  BufferIndex = 0;
 32a:	10 92 a7 00 	sts	0x00A7, r1	; 0x8000a7 <TwoWire::BufferIndex>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:365
  BufferLength = 0;
 32e:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <TwoWire::BufferLength>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:367

  transmitting = 0;
 332:	10 92 a6 00 	sts	0x00A6, r1	; 0x8000a6 <TwoWire::transmitting>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:369

  USI_TWI_Master_Initialise();
 336:	4e df       	rcall	.-356    	; 0x1d4 <USI_TWI_Master_Initialise>
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:30
 * on a scan!
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::begin(bool addr_detect) {
  _wire->begin();
  _begun = true;
 338:	81 e0       	ldi	r24, 0x01	; 1
 33a:	8b 83       	std	Y+3, r24	; 0x03
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:33

  if (addr_detect) {
    return detected();
 33c:	ce 01       	movw	r24, r28
 33e:	dc df       	rcall	.-72     	; 0x2f8 <Adafruit_I2CDevice::detected()>
 340:	98 2f       	mov	r25, r24
_ZN18Adafruit_I2CDevice8detectedEv():
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:62
 *    if there's no pullups on I2C
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::detected(void) {
  // Init I2C if not done yet
  if (!_begun && !begin()) {
 342:	81 11       	cpse	r24, r1
 344:	df cf       	rjmp	.-66     	; 0x304 <Adafruit_I2CDevice::detected()+0xc>
 346:	ed cf       	rjmp	.-38     	; 0x322 <Adafruit_I2CDevice::detected()+0x2a>

00000348 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.17]>:
_ZN18Adafruit_I2CDevice15write_then_readEPKhjPhjb.constprop.17():
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:236
 *    @param  read_buffer Pointer to buffer of data to read into.
 *    @param  read_len Number of bytes from buffer to read.
 *    @param  stop Whether to send an I2C STOP signal between the write and read
 *    @return True if write & read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::write_then_read(const uint8_t *write_buffer,
 348:	6f 92       	push	r6
 34a:	7f 92       	push	r7
 34c:	8f 92       	push	r8
 34e:	9f 92       	push	r9
 350:	af 92       	push	r10
 352:	bf 92       	push	r11
 354:	cf 92       	push	r12
 356:	df 92       	push	r13
 358:	ef 92       	push	r14
 35a:	ff 92       	push	r15
 35c:	0f 93       	push	r16
 35e:	1f 93       	push	r17
 360:	cf 93       	push	r28
 362:	df 93       	push	r29
 364:	6c 01       	movw	r12, r24
 366:	5a 01       	movw	r10, r20
 368:	79 01       	movw	r14, r18
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:239
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, bool stop) {
  if (!write(write_buffer, write_len, stop)) {
 36a:	30 e0       	ldi	r19, 0x00	; 0
 36c:	20 e0       	ldi	r18, 0x00	; 0
 36e:	50 e0       	ldi	r21, 0x00	; 0
 370:	40 e0       	ldi	r20, 0x00	; 0
 372:	81 df       	rcall	.-254    	; 0x276 <Adafruit_I2CDevice::write(unsigned char const*, unsigned int, bool, unsigned char const*, unsigned int) [clone .constprop.18]>
 374:	98 2e       	mov	r9, r24
 376:	88 23       	and	r24, r24
 378:	09 f4       	brne	.+2      	; 0x37c <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.17]+0x34>
 37a:	7d c0       	rjmp	.+250    	; 0x476 <__LOCK_REGION_LENGTH__+0x76>
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:175
 *    @param  len Number of bytes from buffer to read.
 *    @param  stop Whether to send an I2C STOP signal on read
 *    @return True if read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::read(uint8_t *buffer, size_t len, bool stop) {
  size_t pos = 0;
 37c:	10 e0       	ldi	r17, 0x00	; 0
 37e:	00 e0       	ldi	r16, 0x00	; 0
read():
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:179
  while (pos < len) {
    size_t read_len =
        ((len - pos) > maxBufferSize()) ? maxBufferSize() : (len - pos);
    bool read_stop = (pos < (len - read_len)) ? false : stop;
 380:	88 24       	eor	r8, r8
 382:	83 94       	inc	r8
 384:	f6 01       	movw	r30, r12
 386:	84 81       	ldd	r24, Z+4	; 0x04
 388:	95 81       	ldd	r25, Z+5	; 0x05
 38a:	e7 01       	movw	r28, r14
 38c:	c0 1b       	sub	r28, r16
 38e:	d1 0b       	sbc	r29, r17
 390:	8c 17       	cp	r24, r28
 392:	9d 07       	cpc	r25, r29
 394:	08 f4       	brcc	.+2      	; 0x398 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.17]+0x50>
 396:	ec 01       	movw	r28, r24
_read():
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:191

bool Adafruit_I2CDevice::_read(uint8_t *buffer, size_t len, bool stop) {
#if defined(TinyWireM_h)
  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len);
#else
  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len, (uint8_t)stop);
 398:	6c 2e       	mov	r6, r28
requestFrom():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:420
    }
    endTransmission(false);
  }

  // reserve one byte for slave address
  quantity++;
 39a:	7c 2e       	mov	r7, r28
 39c:	73 94       	inc	r7
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:426
  // clamp to buffer length
  if (quantity > TWI_BUFFER_SIZE) {
    quantity = TWI_BUFFER_SIZE;
  }
  // set address of targeted slave and read mode
  Buffer[0] = (address << TWI_ADR_BITS) | (1 << TWI_READ_BIT);
 39e:	f6 01       	movw	r30, r12
 3a0:	80 81       	ld	r24, Z
 3a2:	88 0f       	add	r24, r24
 3a4:	81 60       	ori	r24, 0x01	; 1
 3a6:	80 93 66 00 	sts	0x0066, r24	; 0x800066 <__data_end>
read():
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:179
bool Adafruit_I2CDevice::read(uint8_t *buffer, size_t len, bool stop) {
  size_t pos = 0;
  while (pos < len) {
    size_t read_len =
        ((len - pos) > maxBufferSize()) ? maxBufferSize() : (len - pos);
    bool read_stop = (pos < (len - read_len)) ? false : stop;
 3aa:	41 e0       	ldi	r20, 0x01	; 1
 3ac:	c7 01       	movw	r24, r14
 3ae:	8c 1b       	sub	r24, r28
 3b0:	9d 0b       	sbc	r25, r29
 3b2:	08 17       	cp	r16, r24
 3b4:	19 07       	cpc	r17, r25
 3b6:	08 f4       	brcc	.+2      	; 0x3ba <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.17]+0x72>
 3b8:	40 e0       	ldi	r20, 0x00	; 0
requestFrom():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:429
  // perform blocking read into buffer
  uint8_t ret = USI_TWI_Start_Transceiver_With_Data_Stop(Buffer, quantity,
                                                         sendStop);
 3ba:	67 2d       	mov	r22, r7
 3bc:	86 e6       	ldi	r24, 0x66	; 102
 3be:	90 e0       	ldi	r25, 0x00	; 0
 3c0:	79 de       	rcall	.-782    	; 0xb4 <USI_TWI_Start_Transceiver_With_Data_Stop>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:431
  // set rx buffer iterator vars
  BufferIndex = 1; // ignore slave address
 3c2:	80 92 a7 00 	sts	0x00A7, r8	; 0x8000a7 <TwoWire::BufferIndex>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:433
  // check for error
  if (ret == FALSE) {
 3c6:	81 11       	cpse	r24, r1
 3c8:	1b c0       	rjmp	.+54     	; 0x400 <__LOCK_REGION_LENGTH__>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:434
    BufferLength = BufferIndex;
 3ca:	80 92 a8 00 	sts	0x00A8, r8	; 0x8000a8 <TwoWire::BufferLength>
_read():
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:194
  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len);
#else
  size_t recv = _wire->requestFrom((uint8_t)_addr, (uint8_t)len, (uint8_t)stop);
#endif

  if (recv != len) {
 3ce:	8c 17       	cp	r24, r28
 3d0:	1d 06       	cpc	r1, r29
 3d2:	09 f0       	breq	.+2      	; 0x3d6 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.17]+0x8e>
 3d4:	50 c0       	rjmp	.+160    	; 0x476 <__LOCK_REGION_LENGTH__+0x76>
available():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:551

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void) {
  if (BufferLength) {
 3d6:	50 91 a8 00 	lds	r21, 0x00A8	; 0x8000a8 <TwoWire::BufferLength>
 3da:	c5 01       	movw	r24, r10
 3dc:	80 0f       	add	r24, r16
 3de:	91 1f       	adc	r25, r17
 3e0:	dc 01       	movw	r26, r24
 3e2:	41 e0       	ldi	r20, 0x01	; 1
_read():
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:203
    DEBUG_SERIAL.println(recv);
#endif
    return false;
  }

  for (uint16_t i = 0; i < len; i++) {
 3e4:	9d 01       	movw	r18, r26
 3e6:	28 1b       	sub	r18, r24
 3e8:	39 0b       	sbc	r19, r25
 3ea:	2c 17       	cp	r18, r28
 3ec:	3d 07       	cpc	r19, r29
 3ee:	58 f5       	brcc	.+86     	; 0x446 <__LOCK_REGION_LENGTH__+0x46>
available():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:551
 3f0:	55 23       	and	r21, r21
 3f2:	51 f0       	breq	.+20     	; 0x408 <__LOCK_REGION_LENGTH__+0x8>
read():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:565
// or after requestFrom(address, numBytes)
int TwoWire::read(void) {
  int value = -1;

  // get each successive byte on each call
  if (available()) {
 3f4:	54 13       	cpse	r21, r20
 3f6:	20 c0       	rjmp	.+64     	; 0x438 <__LOCK_REGION_LENGTH__+0x38>
_ZN18Adafruit_I2CDevice15write_then_readEPKhjPhjb.constprop.17():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:562

// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void) {
  int value = -1;
 3f8:	2f ef       	ldi	r18, 0xFF	; 255
 3fa:	3f ef       	ldi	r19, 0xFF	; 255
_read():
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:204
    buffer[i] = _wire->read();
 3fc:	2d 93       	st	X+, r18
 3fe:	f2 cf       	rjmp	.-28     	; 0x3e4 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.17]+0x9c>
requestFrom():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:437
  // check for error
  if (ret == FALSE) {
    BufferLength = BufferIndex;
    return 0;
  }
  BufferLength = quantity;
 400:	70 92 a8 00 	sts	0x00A8, r7	; 0x8000a8 <TwoWire::BufferLength>
_ZN18Adafruit_I2CDevice15write_then_readEPKhjPhjb.constprop.17():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:439

  return quantity - 1; // ignore slave address
 404:	86 2d       	mov	r24, r6
 406:	e3 cf       	rjmp	.-58     	; 0x3ce <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.17]+0x86>
USI_TWI_Data_In_Receive_Buffer():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:136

// Check if there is data in the receive buffer.
unsigned char USI_TWI_Data_In_Receive_Buffer(void)
{
  unsigned char tmpRxTail;          // Temporary variable to store volatile
  tmpRxTail = TWI_RxTail;           // Not necessary, but prevents warnings
 408:	30 91 a4 00 	lds	r19, 0x00A4	; 0x8000a4 <TWI_RxTail>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:137
  return (TWI_RxHead - tmpRxTail) & TWI_RX_BUFFER_MASK; // Return 0 (FALSE) if the receive buffer is empty.
 40c:	20 91 a3 00 	lds	r18, 0x00A3	; 0x8000a3 <TWI_RxHead>
 410:	23 1b       	sub	r18, r19
 412:	2f 70       	andi	r18, 0x0F	; 15
read():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:565
// or after requestFrom(address, numBytes)
int TwoWire::read(void) {
  int value = -1;

  // get each successive byte on each call
  if (available()) {
 414:	89 f3       	breq	.-30     	; 0x3f8 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.17]+0xb0>
USI_TWI_Receive_Byte():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:112
// Returns a byte from the receive buffer. Waits if buffer is empty.
unsigned char USI_TWI_Receive_Byte(void)
{
  unsigned char tmptail;
  unsigned char tmpRxTail; // Temporary variable to store volatile
  tmpRxTail = TWI_RxTail;  // Not necessary, but prevents warnings
 416:	30 91 a4 00 	lds	r19, 0x00A4	; 0x8000a4 <TWI_RxTail>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:113
  while (TWI_RxHead == tmpRxTail)
 41a:	20 91 a3 00 	lds	r18, 0x00A3	; 0x8000a3 <TWI_RxHead>
 41e:	32 17       	cp	r19, r18
 420:	e1 f3       	breq	.-8      	; 0x41a <__LOCK_REGION_LENGTH__+0x1a>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:115
    ;
  tmptail    = (TWI_RxTail + 1) & TWI_RX_BUFFER_MASK; // Calculate buffer index
 422:	e0 91 a4 00 	lds	r30, 0x00A4	; 0x8000a4 <TWI_RxTail>
 426:	ef 5f       	subi	r30, 0xFF	; 255
 428:	ef 70       	andi	r30, 0x0F	; 15
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:116
  TWI_RxTail = tmptail;                               // Store new index
 42a:	e0 93 a4 00 	sts	0x00A4, r30	; 0x8000a4 <TWI_RxTail>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:117
  return TWI_RxBuf[tmptail];                          // Return data from the buffer.
 42e:	f0 e0       	ldi	r31, 0x00	; 0
 430:	ea 59       	subi	r30, 0x9A	; 154
 432:	ff 4f       	sbci	r31, 0xFF	; 255
read():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:570
    if (BufferLength) {
      value = Buffer[BufferIndex];
      ++BufferIndex;
    } else {
      value = USI_TWI_Receive_Byte();
 434:	20 81       	ld	r18, Z
 436:	e2 cf       	rjmp	.-60     	; 0x3fc <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.17]+0xb4>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:567
  int value = -1;

  // get each successive byte on each call
  if (available()) {
    if (BufferLength) {
      value = Buffer[BufferIndex];
 438:	e4 2f       	mov	r30, r20
 43a:	f0 e0       	ldi	r31, 0x00	; 0
 43c:	ea 59       	subi	r30, 0x9A	; 154
 43e:	ff 4f       	sbci	r31, 0xFF	; 255
 440:	20 81       	ld	r18, Z
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:568
      ++BufferIndex;
 442:	4f 5f       	subi	r20, 0xFF	; 255
 444:	db cf       	rjmp	.-74     	; 0x3fc <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.17]+0xb4>
 446:	40 93 a7 00 	sts	0x00A7, r20	; 0x8000a7 <TwoWire::BufferIndex>
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:182
    size_t read_len =
        ((len - pos) > maxBufferSize()) ? maxBufferSize() : (len - pos);
    bool read_stop = (pos < (len - read_len)) ? false : stop;
    if (!_read(buffer + pos, read_len, read_stop))
      return false;
    pos += read_len;
 44a:	0c 0f       	add	r16, r28
 44c:	1d 1f       	adc	r17, r29
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:176
 *    @param  stop Whether to send an I2C STOP signal on read
 *    @return True if read was successful, otherwise false.
 */
bool Adafruit_I2CDevice::read(uint8_t *buffer, size_t len, bool stop) {
  size_t pos = 0;
  while (pos < len) {
 44e:	0e 15       	cp	r16, r14
 450:	1f 05       	cpc	r17, r15
 452:	08 f4       	brcc	.+2      	; 0x456 <__LOCK_REGION_LENGTH__+0x56>
 454:	97 cf       	rjmp	.-210    	; 0x384 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.17]+0x3c>
_ZN18Adafruit_I2CDevice15write_then_readEPKhjPhjb.constprop.17():
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:244
  if (!write(write_buffer, write_len, stop)) {
    return false;
  }

  return read(read_buffer, read_len);
}
 456:	89 2d       	mov	r24, r9
 458:	df 91       	pop	r29
 45a:	cf 91       	pop	r28
 45c:	1f 91       	pop	r17
 45e:	0f 91       	pop	r16
 460:	ff 90       	pop	r15
 462:	ef 90       	pop	r14
 464:	df 90       	pop	r13
 466:	cf 90       	pop	r12
 468:	bf 90       	pop	r11
 46a:	af 90       	pop	r10
 46c:	9f 90       	pop	r9
 46e:	8f 90       	pop	r8
 470:	7f 90       	pop	r7
 472:	6f 90       	pop	r6
 474:	08 95       	ret
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:240
 */
bool Adafruit_I2CDevice::write_then_read(const uint8_t *write_buffer,
                                         size_t write_len, uint8_t *read_buffer,
                                         size_t read_len, bool stop) {
  if (!write(write_buffer, write_len, stop)) {
    return false;
 476:	91 2c       	mov	r9, r1
 478:	ee cf       	rjmp	.-36     	; 0x456 <__LOCK_REGION_LENGTH__+0x56>

0000047a <Adafruit_BMP085::read16(unsigned char) [clone .constprop.15]>:
_ZN15Adafruit_BMP0856read16Eh.constprop.15():
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BMP085_Library/Adafruit_BMP085.cpp:293
  i2c_dev->write_then_read(&a, 1, &ret, 1, true);

  return ret;
}

uint16_t Adafruit_BMP085::read16(uint8_t a) {
 47a:	cf 93       	push	r28
 47c:	df 93       	push	r29
 47e:	00 d0       	rcall	.+0      	; 0x480 <Adafruit_BMP085::read16(unsigned char) [clone .constprop.15]+0x6>
 480:	1f 92       	push	r1
 482:	cd b7       	in	r28, 0x3d	; 61
 484:	de b7       	in	r29, 0x3e	; 62
 486:	8b 83       	std	Y+3, r24	; 0x03
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BMP085_Library/Adafruit_BMP085.cpp:300
  uint16_t ret;

  // send 1 byte, reset i2c, read 2 bytes
  // we could typecast uint16_t as uint8_t array but would need to ensure proper
  // endianness
  i2c_dev->write_then_read(&a, 1, retbuf, 2, true);
 488:	22 e0       	ldi	r18, 0x02	; 2
 48a:	30 e0       	ldi	r19, 0x00	; 0
 48c:	ae 01       	movw	r20, r28
 48e:	4f 5f       	subi	r20, 0xFF	; 255
 490:	5f 4f       	sbci	r21, 0xFF	; 255
 492:	be 01       	movw	r22, r28
 494:	6d 5f       	subi	r22, 0xFD	; 253
 496:	7f 4f       	sbci	r23, 0xFF	; 255
 498:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <bmp>
 49c:	90 91 8b 00 	lds	r25, 0x008B	; 0x80008b <bmp+0x1>
 4a0:	53 df       	rcall	.-346    	; 0x348 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.17]>
 4a2:	89 81       	ldd	r24, Y+1	; 0x01
 4a4:	9a 81       	ldd	r25, Y+2	; 0x02
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BMP085_Library/Adafruit_BMP085.cpp:306

  // write_then_read uses uint8_t array
  ret = retbuf[1] | (retbuf[0] << 8);

  return ret;
}
 4a6:	98 27       	eor	r25, r24
 4a8:	89 27       	eor	r24, r25
 4aa:	98 27       	eor	r25, r24
 4ac:	0f 90       	pop	r0
 4ae:	0f 90       	pop	r0
 4b0:	0f 90       	pop	r0
 4b2:	df 91       	pop	r29
 4b4:	cf 91       	pop	r28
 4b6:	08 95       	ret

000004b8 <digitalWrite.constprop.8>:
digitalWrite.constprop.8():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:113
        //cbi(TCCR1, COM1A0);
      } else
    #endif
    #if defined(TCCR1) && defined(COM1B1) // x5
      if( timer == TIMER1B){
        GTCCR &= ~(1<<COM1B1);
 4b8:	9c b5       	in	r25, 0x2c	; 44
 4ba:	9f 7d       	andi	r25, 0xDF	; 223
 4bc:	9c bd       	out	0x2c, r25	; 44
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:152
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);

  out = portOutputRegister(port);

  if (val == LOW) {
 4be:	81 11       	cpse	r24, r1
 4c0:	05 c0       	rjmp	.+10     	; 0x4cc <digitalWrite.constprop.8+0x14>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:153
    uint8_t oldSREG = SREG;
 4c2:	8f b7       	in	r24, 0x3f	; 63
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:154
    cli();
 4c4:	f8 94       	cli
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:155
    *out &= ~bit;
 4c6:	c4 98       	cbi	0x18, 4	; 24
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:161
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
    cli();
    *out |= bit;
    SREG = oldSREG;
 4c8:	8f bf       	out	0x3f, r24	; 63
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:163
  }
}
 4ca:	08 95       	ret
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:158
    uint8_t oldSREG = SREG;
    cli();
    *out &= ~bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
 4cc:	8f b7       	in	r24, 0x3f	; 63
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:159
    cli();
 4ce:	f8 94       	cli
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:160
    *out |= bit;
 4d0:	c4 9a       	sbi	0x18, 4	; 24
 4d2:	fa cf       	rjmp	.-12     	; 0x4c8 <digitalWrite.constprop.8+0x10>

000004d4 <__vector_14>:
__vector_14():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:207
/*----------------------------------------------------------
 Handles all the communication. Is disabled only when waiting
 for new Start Condition.
----------------------------------------------------------*/
ISR(USI_OVERFLOW_VECTOR)
{
 4d4:	1f 92       	push	r1
 4d6:	0f 92       	push	r0
 4d8:	0f b6       	in	r0, 0x3f	; 63
 4da:	0f 92       	push	r0
 4dc:	11 24       	eor	r1, r1
 4de:	2f 93       	push	r18
 4e0:	8f 93       	push	r24
 4e2:	9f 93       	push	r25
 4e4:	ef 93       	push	r30
 4e6:	ff 93       	push	r31
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:212
  unsigned char tmpRxHead;
  unsigned char tmpTxTail; // Temporary variables to store volatiles
  unsigned char tmpUSIDR;

  switch (USI_TWI_Overflow_State) {
 4e8:	80 91 88 00 	lds	r24, 0x0088	; 0x800088 <USI_TWI_Overflow_State>
 4ec:	82 30       	cpi	r24, 0x02	; 2
 4ee:	09 f4       	brne	.+2      	; 0x4f2 <__vector_14+0x1e>
 4f0:	5e c0       	rjmp	.+188    	; 0x5ae <__vector_14+0xda>
 4f2:	78 f4       	brcc	.+30     	; 0x512 <__vector_14+0x3e>
 4f4:	88 23       	and	r24, r24
 4f6:	49 f1       	breq	.+82     	; 0x54a <__vector_14+0x76>
 4f8:	81 30       	cpi	r24, 0x01	; 1
 4fa:	09 f4       	brne	.+2      	; 0x4fe <__vector_14+0x2a>
 4fc:	3e c0       	rjmp	.+124    	; 0x57a <__vector_14+0xa6>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:306
    {
      SET_USI_TO_SEND_NACK();
    }
    break;
  }
}
 4fe:	ff 91       	pop	r31
 500:	ef 91       	pop	r30
 502:	9f 91       	pop	r25
 504:	8f 91       	pop	r24
 506:	2f 91       	pop	r18
 508:	0f 90       	pop	r0
 50a:	0f be       	out	0x3f, r0	; 63
 50c:	0f 90       	pop	r0
 50e:	1f 90       	pop	r1
 510:	18 95       	reti
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:212
{
  unsigned char tmpRxHead;
  unsigned char tmpTxTail; // Temporary variables to store volatiles
  unsigned char tmpUSIDR;

  switch (USI_TWI_Overflow_State) {
 512:	84 30       	cpi	r24, 0x04	; 4
 514:	09 f4       	brne	.+2      	; 0x518 <__vector_14+0x44>
 516:	51 c0       	rjmp	.+162    	; 0x5ba <__vector_14+0xe6>
 518:	48 f1       	brcs	.+82     	; 0x56c <__vector_14+0x98>
 51a:	85 30       	cpi	r24, 0x05	; 5
 51c:	81 f7       	brne	.-32     	; 0x4fe <__vector_14+0x2a>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:293
    break;

  // Copy data from USIDR and send ACK. Next USI_SLAVE_REQUEST_DATA
  case USI_SLAVE_GET_DATA_AND_SEND_ACK:
    // Put data into Buffer
    USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
 51e:	84 e0       	ldi	r24, 0x04	; 4
 520:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <USI_TWI_Overflow_State>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:294
    tmpUSIDR              = USIDR; // Not necessary, but prevents warnings
 524:	9f b1       	in	r25, 0x0f	; 15
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:295
    tmpRxHead = (TWI_RxHead + 1) & TWI_RX_BUFFER_MASK;
 526:	80 91 a3 00 	lds	r24, 0x00A3	; 0x8000a3 <TWI_RxHead>
 52a:	8f 5f       	subi	r24, 0xFF	; 255
 52c:	8f 70       	andi	r24, 0x0F	; 15
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:296
    if (TWI_RxTail != tmpRxHead) {
 52e:	20 91 a4 00 	lds	r18, 0x00A4	; 0x8000a4 <TWI_RxTail>
 532:	28 17       	cp	r18, r24
 534:	09 f4       	brne	.+2      	; 0x538 <__vector_14+0x64>
 536:	46 c0       	rjmp	.+140    	; 0x5c4 <__vector_14+0xf0>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:297
      TWI_RxHead            = tmpRxHead;
 538:	80 93 a3 00 	sts	0x00A3, r24	; 0x8000a3 <TWI_RxHead>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:298
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
 53c:	e0 91 a3 00 	lds	r30, 0x00A3	; 0x8000a3 <TWI_RxHead>
 540:	f0 e0       	ldi	r31, 0x00	; 0
 542:	ea 59       	subi	r30, 0x9A	; 154
 544:	ff 4f       	sbci	r31, 0xFF	; 255
 546:	90 83       	st	Z, r25
 548:	0b c0       	rjmp	.+22     	; 0x560 <__vector_14+0x8c>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:216

  switch (USI_TWI_Overflow_State) {
  // ---------- Address mode ----------
  // Check address and send ACK (and next USI_SLAVE_SEND_DATA) if OK, else reset USI.
  case USI_SLAVE_CHECK_ADDRESS:
    if ((USIDR == 0) || ((USIDR >> 1) == TWI_slaveAddress)) {
 54a:	8f b1       	in	r24, 0x0f	; 15
 54c:	88 23       	and	r24, r24
 54e:	19 f0       	breq	.+6      	; 0x556 <__vector_14+0x82>
 550:	8f b1       	in	r24, 0x0f	; 15
 552:	86 95       	lsr	r24
 554:	71 f4       	brne	.+28     	; 0x572 <__vector_14+0x9e>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:217
      if (USIDR & 0x01) {
 556:	78 9b       	sbis	0x0f, 0	; 15
 558:	07 c0       	rjmp	.+14     	; 0x568 <__vector_14+0x94>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:224
          // reset tx buffer and call callback
          tmpTxTail = TWI_TxHead;
          TWI_TxTail = tmpTxTail;
          USI_TWI_On_Slave_Transmit();
        }
        USI_TWI_Overflow_State = USI_SLAVE_SEND_DATA;
 55a:	81 e0       	ldi	r24, 0x01	; 1
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:226
      } else {
        USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
 55c:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <USI_TWI_Overflow_State>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:228
      }
      SET_USI_TO_SEND_ACK();
 560:	1f b8       	out	0x0f, r1	; 15
 562:	b8 9a       	sbi	0x17, 0	; 23
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:302
      TWI_RxHead            = tmpRxHead;
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
      SET_USI_TO_SEND_ACK();
    } else // If the buffer is full then:
    {
      SET_USI_TO_SEND_NACK();
 564:	8e e7       	ldi	r24, 0x7E	; 126
 566:	21 c0       	rjmp	.+66     	; 0x5aa <__vector_14+0xd6>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:226
          TWI_TxTail = tmpTxTail;
          USI_TWI_On_Slave_Transmit();
        }
        USI_TWI_Overflow_State = USI_SLAVE_SEND_DATA;
      } else {
        USI_TWI_Overflow_State = USI_SLAVE_REQUEST_DATA;
 568:	84 e0       	ldi	r24, 0x04	; 4
 56a:	f8 cf       	rjmp	.-16     	; 0x55c <__vector_14+0x88>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:237
    break;

  // ----- Master write data mode ------
  // Check reply and goto USI_SLAVE_SEND_DATA if OK, else reset USI.
  case USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA:
    if (USIDR) // If NACK, the master does not want more data.
 56c:	8f b1       	in	r24, 0x0f	; 15
 56e:	88 23       	and	r24, r24
 570:	21 f0       	breq	.+8      	; 0x57a <__vector_14+0xa6>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:255
    if (TWI_TxHead != tmpTxTail) {
      TWI_TxTail = (TWI_TxTail + 1) & TWI_TX_BUFFER_MASK;
      USIDR      = TWI_TxBuf[TWI_TxTail];
    } else // If the buffer is empty then:
    {
      SET_USI_TO_TWI_START_CONDITION_MODE();
 572:	b8 98       	cbi	0x17, 0	; 23
 574:	88 ea       	ldi	r24, 0xA8	; 168
 576:	8d b9       	out	0x0d, r24	; 13
 578:	17 c0       	rjmp	.+46     	; 0x5a8 <__vector_14+0xd4>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:249
  // Copy data from buffer to USIDR and set USI to shift byte. Next USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA
  /* Falls through. */
  case USI_SLAVE_SEND_DATA:

    // Get data from Buffer
    tmpTxTail = TWI_TxTail; // Not necessary, but prevents warnings
 57a:	80 91 86 00 	lds	r24, 0x0086	; 0x800086 <TWI_TxTail>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:250
    if (TWI_TxHead != tmpTxTail) {
 57e:	90 91 87 00 	lds	r25, 0x0087	; 0x800087 <TWI_TxHead>
 582:	98 17       	cp	r25, r24
 584:	b1 f3       	breq	.-20     	; 0x572 <__vector_14+0x9e>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:251
      TWI_TxTail = (TWI_TxTail + 1) & TWI_TX_BUFFER_MASK;
 586:	80 91 86 00 	lds	r24, 0x0086	; 0x800086 <TWI_TxTail>
 58a:	8f 5f       	subi	r24, 0xFF	; 255
 58c:	8f 70       	andi	r24, 0x0F	; 15
 58e:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <TWI_TxTail>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:252
      USIDR      = TWI_TxBuf[TWI_TxTail];
 592:	e0 91 86 00 	lds	r30, 0x0086	; 0x800086 <TWI_TxTail>
 596:	f0 e0       	ldi	r31, 0x00	; 0
 598:	ea 58       	subi	r30, 0x8A	; 138
 59a:	ff 4f       	sbci	r31, 0xFF	; 255
 59c:	80 81       	ld	r24, Z
 59e:	8f b9       	out	0x0f, r24	; 15
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:258
    } else // If the buffer is empty then:
    {
      SET_USI_TO_TWI_START_CONDITION_MODE();
      return;
    }
    USI_TWI_Overflow_State = USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA;
 5a0:	82 e0       	ldi	r24, 0x02	; 2
 5a2:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <USI_TWI_Overflow_State>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:259
    SET_USI_TO_SEND_DATA();
 5a6:	b8 9a       	sbi	0x17, 0	; 23
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:272

  // ----- Master read data mode ------
  // Set USI to sample data from master. Next USI_SLAVE_GET_DATA_AND_SEND_ACK.
  case USI_SLAVE_REQUEST_DATA:
    USI_TWI_Overflow_State = USI_SLAVE_GET_DATA_AND_SEND_ACK;
    SET_USI_TO_READ_DATA();
 5a8:	80 e7       	ldi	r24, 0x70	; 112
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:302
      TWI_RxHead            = tmpRxHead;
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
      SET_USI_TO_SEND_ACK();
    } else // If the buffer is full then:
    {
      SET_USI_TO_SEND_NACK();
 5aa:	8e b9       	out	0x0e, r24	; 14
 5ac:	a8 cf       	rjmp	.-176    	; 0x4fe <__vector_14+0x2a>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:264
    SET_USI_TO_SEND_DATA();
    break;

  // Set USI to sample reply from master. Next USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA
  case USI_SLAVE_REQUEST_REPLY_FROM_SEND_DATA:
    USI_TWI_Overflow_State = USI_SLAVE_CHECK_REPLY_FROM_SEND_DATA;
 5ae:	83 e0       	ldi	r24, 0x03	; 3
 5b0:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <USI_TWI_Overflow_State>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:265
    SET_USI_TO_READ_ACK();
 5b4:	b8 98       	cbi	0x17, 0	; 23
 5b6:	1f b8       	out	0x0f, r1	; 15
 5b8:	d5 cf       	rjmp	.-86     	; 0x564 <__vector_14+0x90>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:271
    break;

  // ----- Master read data mode ------
  // Set USI to sample data from master. Next USI_SLAVE_GET_DATA_AND_SEND_ACK.
  case USI_SLAVE_REQUEST_DATA:
    USI_TWI_Overflow_State = USI_SLAVE_GET_DATA_AND_SEND_ACK;
 5ba:	85 e0       	ldi	r24, 0x05	; 5
 5bc:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <USI_TWI_Overflow_State>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:272
    SET_USI_TO_READ_DATA();
 5c0:	b8 98       	cbi	0x17, 0	; 23
 5c2:	f2 cf       	rjmp	.-28     	; 0x5a8 <__vector_14+0xd4>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:302
      TWI_RxHead            = tmpRxHead;
      TWI_RxBuf[TWI_RxHead] = tmpUSIDR;
      SET_USI_TO_SEND_ACK();
    } else // If the buffer is full then:
    {
      SET_USI_TO_SEND_NACK();
 5c4:	b8 98       	cbi	0x17, 0	; 23
 5c6:	ce cf       	rjmp	.-100    	; 0x564 <__vector_14+0x90>

000005c8 <__vector_13>:
__vector_13():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:165
ISR(USI_START_VECTOR)
#elif __ICCAVR__
#pragma vector = USI_START_VECTOR
__interrupt void USI_Start_Condition_ISR(void)
#endif
{
 5c8:	1f 92       	push	r1
 5ca:	0f 92       	push	r0
 5cc:	0f b6       	in	r0, 0x3f	; 63
 5ce:	0f 92       	push	r0
 5d0:	11 24       	eor	r1, r1
 5d2:	8f 93       	push	r24
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:178
      // reset rx buffer
      TWI_RxTail = tmpRxHead;
    }
  }

  USI_TWI_Overflow_State = USI_SLAVE_CHECK_ADDRESS;
 5d4:	10 92 88 00 	sts	0x0088, r1	; 0x800088 <USI_TWI_Overflow_State>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:179
  DDR_USI &= ~(1 << PORT_USI_SDA); // Set SDA as input
 5d8:	b8 98       	cbi	0x17, 0	; 23
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:180
  while ((tmpPin = (PIN_USI_CL & (1 << PORT_USI_SCL))) && ((PIN_USI & (1 << PIN_USI_SDA)) == 0))
 5da:	b2 9b       	sbis	0x16, 2	; 22
 5dc:	04 c0       	rjmp	.+8      	; 0x5e6 <__vector_13+0x1e>
 5de:	b0 9b       	sbis	0x16, 0	; 22
 5e0:	fc cf       	rjmp	.-8      	; 0x5da <__vector_13+0x12>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:185
    ; // Wait for SCL to go low to ensure the "Start Condition" has completed.
        // If a Stop condition arises then leave the interrupt to prevent waiting forever.
  if (tmpPin) {
    // Stop Condition (waiting for next Start Condition)
    USICR = (1 << USISIE) | (0 << USIOIE) | // Enable Start Condition Interrupt. Disable Overflow Interrupt.
 5e2:	88 ea       	ldi	r24, 0xA8	; 168
 5e4:	01 c0       	rjmp	.+2      	; 0x5e8 <__vector_13+0x20>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:192
                                            // to first Start Condition (potential failure)
            (1 << USICS1) | (0 << USICS0) | (0 << USICLK) | // Shift Register Clock Source = External, positive edge
            (0 << USITC);
  } else {
    // really Start Condition (Enable Overflow Interrupt)
    USICR = (1 << USISIE) | (1 << USIOIE)
 5e6:	88 ef       	ldi	r24, 0xF8	; 248
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:185
  while ((tmpPin = (PIN_USI_CL & (1 << PORT_USI_SCL))) && ((PIN_USI & (1 << PIN_USI_SDA)) == 0))
    ; // Wait for SCL to go low to ensure the "Start Condition" has completed.
        // If a Stop condition arises then leave the interrupt to prevent waiting forever.
  if (tmpPin) {
    // Stop Condition (waiting for next Start Condition)
    USICR = (1 << USISIE) | (0 << USIOIE) | // Enable Start Condition Interrupt. Disable Overflow Interrupt.
 5e8:	8d b9       	out	0x0d, r24	; 13
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:198
            | // Enable Overflow and Start Condition Interrupt. (Keep StartCondInt to detect RESTART)
            (1 << USIWM1) | (1 << USIWM0) |                 // Set USI in Two-wire mode.
            (1 << USICS1) | (0 << USICS0) | (0 << USICLK) | // Shift Register Clock Source = External, positive edge
            (0 << USITC);
  }
  USISR = (1 << USI_START_COND_INT) | (1 << USIOIF) | (1 << USIPF) | (1 << USIDC) | // Clear flags
 5ea:	80 ef       	ldi	r24, 0xF0	; 240
 5ec:	8e b9       	out	0x0e, r24	; 14
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src\USI_TWI_Slave/USI_TWI_Slave.c:200
          (0x0 << USICNT0); // Set USI to sample 8 bits i.e. count 16 external pin toggles.
}
 5ee:	8f 91       	pop	r24
 5f0:	0f 90       	pop	r0
 5f2:	0f be       	out	0x3f, r0	; 63
 5f4:	0f 90       	pop	r0
 5f6:	1f 90       	pop	r1
 5f8:	18 95       	reti

000005fa <main>:
main():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/main.cpp:4
#include <Arduino.h>

int main(void)
{
 5fa:	cf 93       	push	r28
 5fc:	df 93       	push	r29
 5fe:	00 d0       	rcall	.+0      	; 0x600 <main+0x6>
 600:	cd b7       	in	r28, 0x3d	; 61
 602:	de b7       	in	r29, 0x3e	; 62
init():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1138
*/

  // Use the Millis Timer for fast PWM (unless it doesn't have an output).
  #if (TIMER_TO_USE_FOR_MILLIS == 0)
    #if defined(WGM01) // if Timer0 has PWM
      TCCR0A = (1<<WGM01) | (1<<WGM00);
 604:	83 e0       	ldi	r24, 0x03	; 3
 606:	8a bd       	out	0x2a, r24	; 42
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1141
    #endif
    #if defined(TCCR0B) //The x61 has a wacky Timer0!
      TCCR0B = (MillisTimer_Prescale_Index << CS00);
 608:	83 bf       	out	0x33, r24	; 51
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1162
    TCCR1A = 1<<WGM10;
    TCCR1B = (1<<WGM12) | (MillisTimer_Prescale_Index << CS10);
  #endif

  // this needs to be called before setup() or some functions won't work there
  sei();
 60a:	78 94       	sei
initToneTimerInternal():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:958
    #elif defined(__AVR_ATtiny43__)
      TCCR1A = 3; //WGM 10=1, WGM11=1
      TCCR1B = 3; //prescaler of 64
    #elif (TIMER_TO_USE_FOR_TONE == 1) && defined(TCCR1) // ATtiny x5
      // Use the Tone Timer for fast PWM as phase correct not supported by this timer
      GTCCR = (1<<PWM1B);
 60c:	80 e4       	ldi	r24, 0x40	; 64
 60e:	8c bd       	out	0x2c, r24	; 44
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:959
      OCR1C = 0xFF; //Use 255 as the top to match with the others as this module doesn't have a 8bit PWM mode.
 610:	8f ef       	ldi	r24, 0xFF	; 255
 612:	8d bd       	out	0x2d, r24	; 45
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:960
      TCCR1 = (1<<CTC1) | (1<<PWM1A) | (ToneTimer_Prescale_Index << CS10);
 614:	87 ec       	ldi	r24, 0xC7	; 199
 616:	80 bf       	out	0x30, r24	; 48
init():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring.c:1214
  #if defined( INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER ) && INITIALIZE_ANALOG_TO_DIGITAL_CONVERTER
    #if defined(ADCSRA)
      // set a2d prescale factor
      // ADCSRA = (ADCSRA & ~((1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0))) | (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
      // dude, this is being called on startup. We know that ADCSRA is 0! Why add a RMW cycle?!
      ADCSRA = (ADC_ARDUINO_PRESCALER << ADPS0) | (1<<ADEN);
 618:	86 e8       	ldi	r24, 0x86	; 134
 61a:	86 b9       	out	0x06, r24	; 6
pinMode():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:57
                cli();
    *reg &= ~bit;
    *out |= bit;
    SREG = oldSREG;
  } else {
    uint8_t oldSREG = SREG;
 61c:	8f b7       	in	r24, 0x3f	; 63
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:58
                cli();
 61e:	f8 94       	cli
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:59
    *reg |= bit;
 620:	bc 9a       	sbi	0x17, 4	; 23
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/wiring_digital.c:60
    SREG = oldSREG;
 622:	8f bf       	out	0x3f, r24	; 63
 624:	04 e0       	ldi	r16, 0x04	; 4
 626:	10 e0       	ldi	r17, 0x00	; 0
setup():
C:\Users\borno\Desktop\\\1.0/1.0.ino:17
 628:	80 e0       	ldi	r24, 0x00	; 0
 62a:	46 df       	rcall	.-372    	; 0x4b8 <digitalWrite.constprop.8>
C:\Users\borno\Desktop\\\1.0/1.0.ino:18
 62c:	60 e9       	ldi	r22, 0x90	; 144
 62e:	71 e0       	ldi	r23, 0x01	; 1
 630:	80 e0       	ldi	r24, 0x00	; 0
 632:	90 e0       	ldi	r25, 0x00	; 0
 634:	1b dd       	rcall	.-1482   	; 0x6c <delay>
C:\Users\borno\Desktop\\\1.0/1.0.ino:19
 636:	81 e0       	ldi	r24, 0x01	; 1
 638:	3f df       	rcall	.-386    	; 0x4b8 <digitalWrite.constprop.8>
C:\Users\borno\Desktop\\\1.0/1.0.ino:20
 63a:	60 e9       	ldi	r22, 0x90	; 144
 63c:	71 e0       	ldi	r23, 0x01	; 1
 63e:	80 e0       	ldi	r24, 0x00	; 0
 640:	90 e0       	ldi	r25, 0x00	; 0
 642:	14 dd       	rcall	.-1496   	; 0x6c <delay>
 644:	01 50       	subi	r16, 0x01	; 1
 646:	11 09       	sbc	r17, r1
C:\Users\borno\Desktop\\\1.0/1.0.ino:16
 648:	79 f7       	brne	.-34     	; 0x628 <main+0x2e>
begin():
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BMP085_Library/Adafruit_BMP085.cpp:39
Adafruit_BMP085::Adafruit_BMP085() { i2c_dev = nullptr; }

bool Adafruit_BMP085::begin(uint8_t mode, TwoWire *wire) {
  if (mode > BMP085_ULTRAHIGHRES)
    mode = BMP085_ULTRAHIGHRES;
  oversampling = mode;
 64a:	83 e0       	ldi	r24, 0x03	; 3
 64c:	80 93 8c 00 	sts	0x008C, r24	; 0x80008c <bmp+0x2>
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BMP085_Library/Adafruit_BMP085.cpp:41

  if (i2c_dev) {
 650:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <bmp>
 654:	90 91 8b 00 	lds	r25, 0x008B	; 0x80008b <bmp+0x1>
 658:	00 97       	sbiw	r24, 0x00	; 0
 65a:	09 f0       	breq	.+2      	; 0x65e <main+0x64>
operator delete():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/new.cpp:30
void *operator new[](size_t size) {
  return malloc(size);
}

void operator delete(void * ptr) {
  free(ptr);
 65c:	22 d1       	rcall	.+580    	; 0x8a2 <free>
operator new():
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\cores\tiny/new.cpp:22
*/

#include <stdlib.h>

void *operator new(size_t size) {
  return malloc(size);
 65e:	86 e0       	ldi	r24, 0x06	; 6
 660:	90 e0       	ldi	r25, 0x00	; 0
 662:	83 d0       	rcall	.+262    	; 0x76a <malloc>
 664:	8c 01       	movw	r16, r24
__base_ctor ():
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:11
 *    @brief  Create an I2C device at a given address
 *    @param  addr The 7-bit I2C address for the device
 *    @param  theWire The I2C bus to use, defaults to &Wire
 */
Adafruit_I2CDevice::Adafruit_I2CDevice(uint8_t addr, TwoWire *theWire) {
  _addr = addr;
 666:	87 e7       	ldi	r24, 0x77	; 119
 668:	f8 01       	movw	r30, r16
 66a:	80 83       	st	Z, r24
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:12
  _wire = theWire;
 66c:	89 e8       	ldi	r24, 0x89	; 137
 66e:	90 e0       	ldi	r25, 0x00	; 0
 670:	92 83       	std	Z+2, r25	; 0x02
 672:	81 83       	std	Z+1, r24	; 0x01
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:13
  _begun = false;
 674:	13 82       	std	Z+3, r1	; 0x03
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:17
#ifdef ARDUINO_ARCH_SAMD
  _maxBufferSize = 250; // as defined in Wire.h's RingBuffer
#else
  _maxBufferSize = 32;
 676:	80 e2       	ldi	r24, 0x20	; 32
 678:	90 e0       	ldi	r25, 0x00	; 0
 67a:	95 83       	std	Z+5, r25	; 0x05
 67c:	84 83       	std	Z+4, r24	; 0x04
begin():
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BMP085_Library/Adafruit_BMP085.cpp:45
    delete i2c_dev; // remove old interface
  }

  i2c_dev = new Adafruit_I2CDevice(BMP085_I2CADDR, wire);
 67e:	10 93 8b 00 	sts	0x008B, r17	; 0x80008b <bmp+0x1>
 682:	00 93 8a 00 	sts	0x008A, r16	; 0x80008a <bmp>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:364
}

// Public Methods //////////////////////////////////////////////////////////////

void TwoWire::begin(void) {
  BufferIndex = 0;
 686:	10 92 a7 00 	sts	0x00A7, r1	; 0x8000a7 <TwoWire::BufferIndex>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:365
  BufferLength = 0;
 68a:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <TwoWire::BufferLength>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:367

  transmitting = 0;
 68e:	10 92 a6 00 	sts	0x00A6, r1	; 0x8000a6 <TwoWire::transmitting>
C:\Users\borno\AppData\Local\Arduino15\packages\ATTinyCore\hardware\avr\1.5.2\libraries\Wire\src/Wire.cpp:369

  USI_TWI_Master_Initialise();
 692:	a0 dd       	rcall	.-1216   	; 0x1d4 <USI_TWI_Master_Initialise>
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:30
 * on a scan!
 *    @return True if I2C initialized and a device with the addr found
 */
bool Adafruit_I2CDevice::begin(bool addr_detect) {
  _wire->begin();
  _begun = true;
 694:	81 e0       	ldi	r24, 0x01	; 1
 696:	f8 01       	movw	r30, r16
 698:	83 83       	std	Z+3, r24	; 0x03
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BusIO/Adafruit_I2CDevice.cpp:33

  if (addr_detect) {
    return detected();
 69a:	c8 01       	movw	r24, r16
 69c:	2d de       	rcall	.-934    	; 0x2f8 <Adafruit_I2CDevice::detected()>
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BMP085_Library/Adafruit_BMP085.cpp:47

  if (!i2c_dev->begin()) {
 69e:	88 23       	and	r24, r24
 6a0:	09 f4       	brne	.+2      	; 0x6a4 <main+0xaa>
 6a2:	55 c0       	rjmp	.+170    	; 0x74e <main+0x154>
 6a4:	80 ed       	ldi	r24, 0xD0	; 208
 6a6:	8a 83       	std	Y+2, r24	; 0x02
read8():
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BMP085_Library/Adafruit_BMP085.cpp:288

uint8_t Adafruit_BMP085::read8(uint8_t a) {
  uint8_t ret;

  // send 1 byte, reset i2c, read 1 byte
  i2c_dev->write_then_read(&a, 1, &ret, 1, true);
 6a8:	21 e0       	ldi	r18, 0x01	; 1
 6aa:	30 e0       	ldi	r19, 0x00	; 0
 6ac:	ae 01       	movw	r20, r28
 6ae:	4f 5f       	subi	r20, 0xFF	; 255
 6b0:	5f 4f       	sbci	r21, 0xFF	; 255
 6b2:	be 01       	movw	r22, r28
 6b4:	6e 5f       	subi	r22, 0xFE	; 254
 6b6:	7f 4f       	sbci	r23, 0xFF	; 255
 6b8:	80 91 8a 00 	lds	r24, 0x008A	; 0x80008a <bmp>
 6bc:	90 91 8b 00 	lds	r25, 0x008B	; 0x80008b <bmp+0x1>
 6c0:	43 de       	rcall	.-890    	; 0x348 <Adafruit_I2CDevice::write_then_read(unsigned char const*, unsigned int, unsigned char*, unsigned int, bool) [clone .constprop.17]>
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BMP085_Library/Adafruit_BMP085.cpp:290

  return ret;
 6c2:	89 81       	ldd	r24, Y+1	; 0x01
begin():
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BMP085_Library/Adafruit_BMP085.cpp:51

  if (!i2c_dev->begin()) {
    return false;
  }

  if (read8(0xD0) != 0x55)
 6c4:	85 35       	cpi	r24, 0x55	; 85
 6c6:	09 f0       	breq	.+2      	; 0x6ca <main+0xd0>
 6c8:	42 c0       	rjmp	.+132    	; 0x74e <main+0x154>
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BMP085_Library/Adafruit_BMP085.cpp:55
    return false;

  /* read calibration data */
  ac1 = read16(BMP085_CAL_AC1);
 6ca:	8a ea       	ldi	r24, 0xAA	; 170
 6cc:	d6 de       	rcall	.-596    	; 0x47a <Adafruit_BMP085::read16(unsigned char) [clone .constprop.15]>
 6ce:	90 93 8e 00 	sts	0x008E, r25	; 0x80008e <bmp+0x4>
 6d2:	80 93 8d 00 	sts	0x008D, r24	; 0x80008d <bmp+0x3>
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BMP085_Library/Adafruit_BMP085.cpp:56
  ac2 = read16(BMP085_CAL_AC2);
 6d6:	8c ea       	ldi	r24, 0xAC	; 172
 6d8:	d0 de       	rcall	.-608    	; 0x47a <Adafruit_BMP085::read16(unsigned char) [clone .constprop.15]>
 6da:	90 93 90 00 	sts	0x0090, r25	; 0x800090 <bmp+0x6>
 6de:	80 93 8f 00 	sts	0x008F, r24	; 0x80008f <bmp+0x5>
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BMP085_Library/Adafruit_BMP085.cpp:57
  ac3 = read16(BMP085_CAL_AC3);
 6e2:	8e ea       	ldi	r24, 0xAE	; 174
 6e4:	ca de       	rcall	.-620    	; 0x47a <Adafruit_BMP085::read16(unsigned char) [clone .constprop.15]>
 6e6:	90 93 92 00 	sts	0x0092, r25	; 0x800092 <bmp+0x8>
 6ea:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <bmp+0x7>
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BMP085_Library/Adafruit_BMP085.cpp:58
  ac4 = read16(BMP085_CAL_AC4);
 6ee:	80 eb       	ldi	r24, 0xB0	; 176
 6f0:	c4 de       	rcall	.-632    	; 0x47a <Adafruit_BMP085::read16(unsigned char) [clone .constprop.15]>
 6f2:	90 93 9e 00 	sts	0x009E, r25	; 0x80009e <bmp+0x14>
 6f6:	80 93 9d 00 	sts	0x009D, r24	; 0x80009d <bmp+0x13>
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BMP085_Library/Adafruit_BMP085.cpp:59
  ac5 = read16(BMP085_CAL_AC5);
 6fa:	82 eb       	ldi	r24, 0xB2	; 178
 6fc:	be de       	rcall	.-644    	; 0x47a <Adafruit_BMP085::read16(unsigned char) [clone .constprop.15]>
 6fe:	90 93 a0 00 	sts	0x00A0, r25	; 0x8000a0 <bmp+0x16>
 702:	80 93 9f 00 	sts	0x009F, r24	; 0x80009f <bmp+0x15>
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BMP085_Library/Adafruit_BMP085.cpp:60
  ac6 = read16(BMP085_CAL_AC6);
 706:	84 eb       	ldi	r24, 0xB4	; 180
 708:	b8 de       	rcall	.-656    	; 0x47a <Adafruit_BMP085::read16(unsigned char) [clone .constprop.15]>
 70a:	90 93 a2 00 	sts	0x00A2, r25	; 0x8000a2 <bmp+0x18>
 70e:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <bmp+0x17>
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BMP085_Library/Adafruit_BMP085.cpp:62

  b1 = read16(BMP085_CAL_B1);
 712:	86 eb       	ldi	r24, 0xB6	; 182
 714:	b2 de       	rcall	.-668    	; 0x47a <Adafruit_BMP085::read16(unsigned char) [clone .constprop.15]>
 716:	90 93 94 00 	sts	0x0094, r25	; 0x800094 <bmp+0xa>
 71a:	80 93 93 00 	sts	0x0093, r24	; 0x800093 <bmp+0x9>
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BMP085_Library/Adafruit_BMP085.cpp:63
  b2 = read16(BMP085_CAL_B2);
 71e:	88 eb       	ldi	r24, 0xB8	; 184
 720:	ac de       	rcall	.-680    	; 0x47a <Adafruit_BMP085::read16(unsigned char) [clone .constprop.15]>
 722:	90 93 96 00 	sts	0x0096, r25	; 0x800096 <bmp+0xc>
 726:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <bmp+0xb>
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BMP085_Library/Adafruit_BMP085.cpp:65

  mb = read16(BMP085_CAL_MB);
 72a:	8a eb       	ldi	r24, 0xBA	; 186
 72c:	a6 de       	rcall	.-692    	; 0x47a <Adafruit_BMP085::read16(unsigned char) [clone .constprop.15]>
 72e:	90 93 98 00 	sts	0x0098, r25	; 0x800098 <bmp+0xe>
 732:	80 93 97 00 	sts	0x0097, r24	; 0x800097 <bmp+0xd>
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BMP085_Library/Adafruit_BMP085.cpp:66
  mc = read16(BMP085_CAL_MC);
 736:	8c eb       	ldi	r24, 0xBC	; 188
 738:	a0 de       	rcall	.-704    	; 0x47a <Adafruit_BMP085::read16(unsigned char) [clone .constprop.15]>
 73a:	90 93 9a 00 	sts	0x009A, r25	; 0x80009a <bmp+0x10>
 73e:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <bmp+0xf>
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BMP085_Library/Adafruit_BMP085.cpp:67
  md = read16(BMP085_CAL_MD);
 742:	8e eb       	ldi	r24, 0xBE	; 190
 744:	9a de       	rcall	.-716    	; 0x47a <Adafruit_BMP085::read16(unsigned char) [clone .constprop.15]>
 746:	90 93 9c 00 	sts	0x009C, r25	; 0x80009c <bmp+0x12>
 74a:	80 93 9b 00 	sts	0x009B, r24	; 0x80009b <bmp+0x11>
setup():
C:\Users\borno\Desktop\\\1.0/1.0.ino:23
 74e:	80 e0       	ldi	r24, 0x00	; 0
 750:	b3 de       	rcall	.-666    	; 0x4b8 <digitalWrite.constprop.8>
 752:	ff cf       	rjmp	.-2      	; 0x752 <main+0x158>

00000754 <_GLOBAL__sub_I_Sum>:
_GLOBAL__sub_I_Sum():
C:\Users\borno\Documents\Arduino\libraries\Adafruit_BMP085_Library/Adafruit_BMP085.cpp:34
 */

#include "Adafruit_BMP085.h"
#include <Adafruit_I2CDevice.h>

Adafruit_BMP085::Adafruit_BMP085() { i2c_dev = nullptr; }
 754:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <bmp+0x1>
 758:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <bmp>
C:\Users\borno\Desktop\\\1.0/1.0.ino:44
 75c:	08 95       	ret

0000075e <__tablejump2__>:
__tablejump2__():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
 75e:	ee 0f       	add	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
 760:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
 762:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
 764:	f4 91       	lpm	r31, Z
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
 766:	e0 2d       	mov	r30, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
 768:	09 94       	ijmp

0000076a <malloc>:
malloc():
 76a:	0f 93       	push	r16
 76c:	1f 93       	push	r17
 76e:	cf 93       	push	r28
 770:	df 93       	push	r29
 772:	82 30       	cpi	r24, 0x02	; 2
 774:	91 05       	cpc	r25, r1
 776:	10 f4       	brcc	.+4      	; 0x77c <malloc+0x12>
 778:	82 e0       	ldi	r24, 0x02	; 2
 77a:	90 e0       	ldi	r25, 0x00	; 0
 77c:	e0 91 ab 00 	lds	r30, 0x00AB	; 0x8000ab <__flp>
 780:	f0 91 ac 00 	lds	r31, 0x00AC	; 0x8000ac <__flp+0x1>
 784:	30 e0       	ldi	r19, 0x00	; 0
 786:	20 e0       	ldi	r18, 0x00	; 0
 788:	b0 e0       	ldi	r27, 0x00	; 0
 78a:	a0 e0       	ldi	r26, 0x00	; 0
 78c:	30 97       	sbiw	r30, 0x00	; 0
 78e:	99 f4       	brne	.+38     	; 0x7b6 <malloc+0x4c>
 790:	21 15       	cp	r18, r1
 792:	31 05       	cpc	r19, r1
 794:	09 f4       	brne	.+2      	; 0x798 <malloc+0x2e>
 796:	4a c0       	rjmp	.+148    	; 0x82c <malloc+0xc2>
 798:	28 1b       	sub	r18, r24
 79a:	39 0b       	sbc	r19, r25
 79c:	24 30       	cpi	r18, 0x04	; 4
 79e:	31 05       	cpc	r19, r1
 7a0:	d8 f5       	brcc	.+118    	; 0x818 <malloc+0xae>
 7a2:	8a 81       	ldd	r24, Y+2	; 0x02
 7a4:	9b 81       	ldd	r25, Y+3	; 0x03
 7a6:	61 15       	cp	r22, r1
 7a8:	71 05       	cpc	r23, r1
 7aa:	89 f1       	breq	.+98     	; 0x80e <malloc+0xa4>
 7ac:	fb 01       	movw	r30, r22
 7ae:	93 83       	std	Z+3, r25	; 0x03
 7b0:	82 83       	std	Z+2, r24	; 0x02
 7b2:	fe 01       	movw	r30, r28
 7b4:	11 c0       	rjmp	.+34     	; 0x7d8 <malloc+0x6e>
 7b6:	40 81       	ld	r20, Z
 7b8:	51 81       	ldd	r21, Z+1	; 0x01
 7ba:	02 81       	ldd	r16, Z+2	; 0x02
 7bc:	13 81       	ldd	r17, Z+3	; 0x03
 7be:	48 17       	cp	r20, r24
 7c0:	59 07       	cpc	r21, r25
 7c2:	e0 f0       	brcs	.+56     	; 0x7fc <malloc+0x92>
 7c4:	48 17       	cp	r20, r24
 7c6:	59 07       	cpc	r21, r25
 7c8:	99 f4       	brne	.+38     	; 0x7f0 <malloc+0x86>
 7ca:	10 97       	sbiw	r26, 0x00	; 0
 7cc:	61 f0       	breq	.+24     	; 0x7e6 <malloc+0x7c>
 7ce:	12 96       	adiw	r26, 0x02	; 2
 7d0:	0c 93       	st	X, r16
 7d2:	12 97       	sbiw	r26, 0x02	; 2
 7d4:	13 96       	adiw	r26, 0x03	; 3
 7d6:	1c 93       	st	X, r17
 7d8:	32 96       	adiw	r30, 0x02	; 2
 7da:	cf 01       	movw	r24, r30
 7dc:	df 91       	pop	r29
 7de:	cf 91       	pop	r28
 7e0:	1f 91       	pop	r17
 7e2:	0f 91       	pop	r16
 7e4:	08 95       	ret
 7e6:	00 93 ab 00 	sts	0x00AB, r16	; 0x8000ab <__flp>
 7ea:	10 93 ac 00 	sts	0x00AC, r17	; 0x8000ac <__flp+0x1>
 7ee:	f4 cf       	rjmp	.-24     	; 0x7d8 <malloc+0x6e>
 7f0:	21 15       	cp	r18, r1
 7f2:	31 05       	cpc	r19, r1
 7f4:	51 f0       	breq	.+20     	; 0x80a <malloc+0xa0>
 7f6:	42 17       	cp	r20, r18
 7f8:	53 07       	cpc	r21, r19
 7fa:	38 f0       	brcs	.+14     	; 0x80a <malloc+0xa0>
 7fc:	a9 01       	movw	r20, r18
 7fe:	db 01       	movw	r26, r22
 800:	9a 01       	movw	r18, r20
 802:	bd 01       	movw	r22, r26
 804:	df 01       	movw	r26, r30
 806:	f8 01       	movw	r30, r16
 808:	c1 cf       	rjmp	.-126    	; 0x78c <malloc+0x22>
 80a:	ef 01       	movw	r28, r30
 80c:	f9 cf       	rjmp	.-14     	; 0x800 <malloc+0x96>
 80e:	90 93 ac 00 	sts	0x00AC, r25	; 0x8000ac <__flp+0x1>
 812:	80 93 ab 00 	sts	0x00AB, r24	; 0x8000ab <__flp>
 816:	cd cf       	rjmp	.-102    	; 0x7b2 <malloc+0x48>
 818:	fe 01       	movw	r30, r28
 81a:	e2 0f       	add	r30, r18
 81c:	f3 1f       	adc	r31, r19
 81e:	81 93       	st	Z+, r24
 820:	91 93       	st	Z+, r25
 822:	22 50       	subi	r18, 0x02	; 2
 824:	31 09       	sbc	r19, r1
 826:	39 83       	std	Y+1, r19	; 0x01
 828:	28 83       	st	Y, r18
 82a:	d7 cf       	rjmp	.-82     	; 0x7da <malloc+0x70>
 82c:	20 91 a9 00 	lds	r18, 0x00A9	; 0x8000a9 <__brkval>
 830:	30 91 aa 00 	lds	r19, 0x00AA	; 0x8000aa <__brkval+0x1>
 834:	23 2b       	or	r18, r19
 836:	41 f4       	brne	.+16     	; 0x848 <malloc+0xde>
 838:	20 91 62 00 	lds	r18, 0x0062	; 0x800062 <__malloc_heap_start>
 83c:	30 91 63 00 	lds	r19, 0x0063	; 0x800063 <__malloc_heap_start+0x1>
 840:	30 93 aa 00 	sts	0x00AA, r19	; 0x8000aa <__brkval+0x1>
 844:	20 93 a9 00 	sts	0x00A9, r18	; 0x8000a9 <__brkval>
 848:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
 84c:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
 850:	21 15       	cp	r18, r1
 852:	31 05       	cpc	r19, r1
 854:	41 f4       	brne	.+16     	; 0x866 <malloc+0xfc>
 856:	2d b7       	in	r18, 0x3d	; 61
 858:	3e b7       	in	r19, 0x3e	; 62
 85a:	40 91 64 00 	lds	r20, 0x0064	; 0x800064 <__malloc_margin>
 85e:	50 91 65 00 	lds	r21, 0x0065	; 0x800065 <__malloc_margin+0x1>
 862:	24 1b       	sub	r18, r20
 864:	35 0b       	sbc	r19, r21
 866:	e0 91 a9 00 	lds	r30, 0x00A9	; 0x8000a9 <__brkval>
 86a:	f0 91 aa 00 	lds	r31, 0x00AA	; 0x8000aa <__brkval+0x1>
 86e:	e2 17       	cp	r30, r18
 870:	f3 07       	cpc	r31, r19
 872:	a0 f4       	brcc	.+40     	; 0x89c <malloc+0x132>
 874:	2e 1b       	sub	r18, r30
 876:	3f 0b       	sbc	r19, r31
 878:	28 17       	cp	r18, r24
 87a:	39 07       	cpc	r19, r25
 87c:	78 f0       	brcs	.+30     	; 0x89c <malloc+0x132>
 87e:	ac 01       	movw	r20, r24
 880:	4e 5f       	subi	r20, 0xFE	; 254
 882:	5f 4f       	sbci	r21, 0xFF	; 255
 884:	24 17       	cp	r18, r20
 886:	35 07       	cpc	r19, r21
 888:	48 f0       	brcs	.+18     	; 0x89c <malloc+0x132>
 88a:	4e 0f       	add	r20, r30
 88c:	5f 1f       	adc	r21, r31
 88e:	50 93 aa 00 	sts	0x00AA, r21	; 0x8000aa <__brkval+0x1>
 892:	40 93 a9 00 	sts	0x00A9, r20	; 0x8000a9 <__brkval>
 896:	81 93       	st	Z+, r24
 898:	91 93       	st	Z+, r25
 89a:	9f cf       	rjmp	.-194    	; 0x7da <malloc+0x70>
 89c:	f0 e0       	ldi	r31, 0x00	; 0
 89e:	e0 e0       	ldi	r30, 0x00	; 0
 8a0:	9c cf       	rjmp	.-200    	; 0x7da <malloc+0x70>

000008a2 <free>:
free():
 8a2:	cf 93       	push	r28
 8a4:	df 93       	push	r29
 8a6:	00 97       	sbiw	r24, 0x00	; 0
 8a8:	e9 f0       	breq	.+58     	; 0x8e4 <free+0x42>
 8aa:	fc 01       	movw	r30, r24
 8ac:	32 97       	sbiw	r30, 0x02	; 2
 8ae:	13 82       	std	Z+3, r1	; 0x03
 8b0:	12 82       	std	Z+2, r1	; 0x02
 8b2:	a0 91 ab 00 	lds	r26, 0x00AB	; 0x8000ab <__flp>
 8b6:	b0 91 ac 00 	lds	r27, 0x00AC	; 0x8000ac <__flp+0x1>
 8ba:	ed 01       	movw	r28, r26
 8bc:	30 e0       	ldi	r19, 0x00	; 0
 8be:	20 e0       	ldi	r18, 0x00	; 0
 8c0:	10 97       	sbiw	r26, 0x00	; 0
 8c2:	a1 f4       	brne	.+40     	; 0x8ec <free+0x4a>
 8c4:	20 81       	ld	r18, Z
 8c6:	31 81       	ldd	r19, Z+1	; 0x01
 8c8:	82 0f       	add	r24, r18
 8ca:	93 1f       	adc	r25, r19
 8cc:	20 91 a9 00 	lds	r18, 0x00A9	; 0x8000a9 <__brkval>
 8d0:	30 91 aa 00 	lds	r19, 0x00AA	; 0x8000aa <__brkval+0x1>
 8d4:	28 17       	cp	r18, r24
 8d6:	39 07       	cpc	r19, r25
 8d8:	09 f0       	breq	.+2      	; 0x8dc <free+0x3a>
 8da:	61 c0       	rjmp	.+194    	; 0x99e <free+0xfc>
 8dc:	f0 93 aa 00 	sts	0x00AA, r31	; 0x8000aa <__brkval+0x1>
 8e0:	e0 93 a9 00 	sts	0x00A9, r30	; 0x8000a9 <__brkval>
 8e4:	df 91       	pop	r29
 8e6:	cf 91       	pop	r28
 8e8:	08 95       	ret
 8ea:	ea 01       	movw	r28, r20
 8ec:	ce 17       	cp	r28, r30
 8ee:	df 07       	cpc	r29, r31
 8f0:	e8 f5       	brcc	.+122    	; 0x96c <free+0xca>
 8f2:	4a 81       	ldd	r20, Y+2	; 0x02
 8f4:	5b 81       	ldd	r21, Y+3	; 0x03
 8f6:	9e 01       	movw	r18, r28
 8f8:	41 15       	cp	r20, r1
 8fa:	51 05       	cpc	r21, r1
 8fc:	b1 f7       	brne	.-20     	; 0x8ea <free+0x48>
 8fe:	e9 01       	movw	r28, r18
 900:	fb 83       	std	Y+3, r31	; 0x03
 902:	ea 83       	std	Y+2, r30	; 0x02
 904:	49 91       	ld	r20, Y+
 906:	59 91       	ld	r21, Y+
 908:	c4 0f       	add	r28, r20
 90a:	d5 1f       	adc	r29, r21
 90c:	ec 17       	cp	r30, r28
 90e:	fd 07       	cpc	r31, r29
 910:	61 f4       	brne	.+24     	; 0x92a <free+0x88>
 912:	80 81       	ld	r24, Z
 914:	91 81       	ldd	r25, Z+1	; 0x01
 916:	02 96       	adiw	r24, 0x02	; 2
 918:	84 0f       	add	r24, r20
 91a:	95 1f       	adc	r25, r21
 91c:	e9 01       	movw	r28, r18
 91e:	99 83       	std	Y+1, r25	; 0x01
 920:	88 83       	st	Y, r24
 922:	82 81       	ldd	r24, Z+2	; 0x02
 924:	93 81       	ldd	r25, Z+3	; 0x03
 926:	9b 83       	std	Y+3, r25	; 0x03
 928:	8a 83       	std	Y+2, r24	; 0x02
 92a:	f0 e0       	ldi	r31, 0x00	; 0
 92c:	e0 e0       	ldi	r30, 0x00	; 0
 92e:	12 96       	adiw	r26, 0x02	; 2
 930:	8d 91       	ld	r24, X+
 932:	9c 91       	ld	r25, X
 934:	13 97       	sbiw	r26, 0x03	; 3
 936:	00 97       	sbiw	r24, 0x00	; 0
 938:	b9 f5       	brne	.+110    	; 0x9a8 <free+0x106>
 93a:	2d 91       	ld	r18, X+
 93c:	3c 91       	ld	r19, X
 93e:	11 97       	sbiw	r26, 0x01	; 1
 940:	cd 01       	movw	r24, r26
 942:	02 96       	adiw	r24, 0x02	; 2
 944:	82 0f       	add	r24, r18
 946:	93 1f       	adc	r25, r19
 948:	20 91 a9 00 	lds	r18, 0x00A9	; 0x8000a9 <__brkval>
 94c:	30 91 aa 00 	lds	r19, 0x00AA	; 0x8000aa <__brkval+0x1>
 950:	28 17       	cp	r18, r24
 952:	39 07       	cpc	r19, r25
 954:	39 f6       	brne	.-114    	; 0x8e4 <free+0x42>
 956:	30 97       	sbiw	r30, 0x00	; 0
 958:	51 f5       	brne	.+84     	; 0x9ae <free+0x10c>
 95a:	10 92 ac 00 	sts	0x00AC, r1	; 0x8000ac <__flp+0x1>
 95e:	10 92 ab 00 	sts	0x00AB, r1	; 0x8000ab <__flp>
 962:	b0 93 aa 00 	sts	0x00AA, r27	; 0x8000aa <__brkval+0x1>
 966:	a0 93 a9 00 	sts	0x00A9, r26	; 0x8000a9 <__brkval>
 96a:	bc cf       	rjmp	.-136    	; 0x8e4 <free+0x42>
 96c:	d3 83       	std	Z+3, r29	; 0x03
 96e:	c2 83       	std	Z+2, r28	; 0x02
 970:	40 81       	ld	r20, Z
 972:	51 81       	ldd	r21, Z+1	; 0x01
 974:	84 0f       	add	r24, r20
 976:	95 1f       	adc	r25, r21
 978:	c8 17       	cp	r28, r24
 97a:	d9 07       	cpc	r29, r25
 97c:	61 f4       	brne	.+24     	; 0x996 <free+0xf4>
 97e:	4e 5f       	subi	r20, 0xFE	; 254
 980:	5f 4f       	sbci	r21, 0xFF	; 255
 982:	88 81       	ld	r24, Y
 984:	99 81       	ldd	r25, Y+1	; 0x01
 986:	48 0f       	add	r20, r24
 988:	59 1f       	adc	r21, r25
 98a:	51 83       	std	Z+1, r21	; 0x01
 98c:	40 83       	st	Z, r20
 98e:	8a 81       	ldd	r24, Y+2	; 0x02
 990:	9b 81       	ldd	r25, Y+3	; 0x03
 992:	93 83       	std	Z+3, r25	; 0x03
 994:	82 83       	std	Z+2, r24	; 0x02
 996:	21 15       	cp	r18, r1
 998:	31 05       	cpc	r19, r1
 99a:	09 f0       	breq	.+2      	; 0x99e <free+0xfc>
 99c:	b0 cf       	rjmp	.-160    	; 0x8fe <free+0x5c>
 99e:	f0 93 ac 00 	sts	0x00AC, r31	; 0x8000ac <__flp+0x1>
 9a2:	e0 93 ab 00 	sts	0x00AB, r30	; 0x8000ab <__flp>
 9a6:	9e cf       	rjmp	.-196    	; 0x8e4 <free+0x42>
 9a8:	fd 01       	movw	r30, r26
 9aa:	dc 01       	movw	r26, r24
 9ac:	c0 cf       	rjmp	.-128    	; 0x92e <free+0x8c>
 9ae:	13 82       	std	Z+3, r1	; 0x03
 9b0:	12 82       	std	Z+2, r1	; 0x02
 9b2:	d7 cf       	rjmp	.-82     	; 0x962 <free+0xc0>

000009b4 <_exit>:
exit():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
 9b4:	f8 94       	cli

000009b6 <__stop_program>:
__stop_program():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr25/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
 9b6:	ff cf       	rjmp	.-2      	; 0x9b6 <__stop_program>
